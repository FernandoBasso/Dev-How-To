                         ━━━━━━━━━━━━━━━━━━━━━━
                                MODULES

                          Fernando Basso (dev)
                         ━━━━━━━━━━━━━━━━━━━━━━


Table of Contents
─────────────────

1 Intro
2 module instance method
3 Inheriting from Object





1 Intro
═══════

  Modules are bundles of methods and constants. You add a module to a
  class to endow the class with extra functionality.

  Modules are similar to classes (but we can't create instances of
  modules), so much that the `Class' class is a subclass of the `Module'
  class, and that means that every class object is also a module object.

  `Kernel' is a module that contains many of the methods that are common
  to all objects, including `load' and `require'.

  ┌────
  │ module Greeter
  │   def hi
  │     'Hi there.'
  │   end
  │ end
  │
  │ class Message
  │   include Greeter
  │ end
  │
  │ msg = Message.new
  │ p msg.hi
  │ # → "Hi there."
  └────

  We defined the method `hi' in the `Greeter' module like if it were an
  instance method of a class, and by including the module in the
  `Message' class, we can use that method in instances of that class as
  if they were defined as instance methods of the class itself.

  In Ruby, we can inherit from a single parent class at a time, but we
  can include (mix in) multiple modules at once.


  ┌────
  │ module StackIt
  │   def stack
  │     @stack ||= []
  │   end
  │
  │   def stack_add(obj)
  │     stack.push(obj)
  │   end
  │
  │   def stack_pop
  │     stack.pop
  │   end
  │ end
  │
  │ class OurStack
  │   include StackIt
  │ end
  │
  │ stk = OurStack.new
  │ stk.stack_add('PHP')
  │ stk.stack_add('JavaScript')
  │ p stk.stack
  │ # → ["PHP", "JavaScript"]
  │
  │ p stk.stack_pop
  │ # → "JavaScript
  │
  │ stk.stack_add('Haskell')
  │ stk.stack_add('Ruby')
  │ p stk.stack
  │ # → ["PHP", "Haskell", "Ruby"]
  └────

  ┌────
  │ ["PHP", "JavaScript"]
  │ "JavaScript"
  │ ["PHP", "Haskell", "Ruby"]
  └────

  `@stack' in `StackIt' module behaves like if it were defined in
  `OutStack' class. Now we could use it in any class, not just in
  `OutStack'.


  Class names should generally be a noun, and module names should
  generally be an adjective. There must be good reasons to not follow
  this convention on any given situation.


2 module instance method
════════════════════════

  This module has an instance method:

  ┌────
  │ module Pluralable
  │   def pluralize(word, count, plural = nil)
  │     return word if 1 == count
  │     return plural if plural
  │     return "#{count} #{word}s"
  │   end
  │ end
  │
  │ class Message
  │   include Pluralable
  │ end
  │
  │ msg = Message.new
  │ p msg.pluralize('apple', 0)
  │ # → "0 apples"
  │
  │ p msg.pluralize(1, 'apple')
  │ # → "1 apple"
  │
  │ p msg.pluralize('apple', 2)
  │ # → "2 apples"
  │
  │ p msg.pluralize('foot', 0, 'feet')
  │ # → "0 feet"
  │
  │ p msg.pluralize('foot', 1)
  │ # → "1 foot"
  │
  │ p msg.pluralize('foot', 2, 'feet')
  │ # → "0 feet"
  └────

  The method `pluralize' in the `Pluralable' module is an instance
  method of that module, and when it gets /mixed into/ (included) into
  the class `Message' that class can use the module as if it were and
  instance method of the class itself. What happens is that there is a
  module lookup going on. When something like a method or variable can't
  be found on a class, the lookup mechanism looks in parent classes and
  included modules to try to find the variable or method.

  Even if a super super super class includes a module that contains a
  certain method, the current object will be able to invoke that method.

  If a method is not found, the result is an error condition that
  triggers the call of the method `method_missing' (and we can override
  it to customize what happens when this method is invoked).

  `BasicObject' is the first class in the hierarchy, then we have the
  `Object' class, and `Kernel' is a module that `Object' mixes in.

  All classes that inherit from `Object' automatically inherit stuff
  provided by `Kernel'.

  TODO: Draw some diagram about this hierarchy of modules and classes to
  insert at this point.


3 Inheriting from Object
════════════════════════

  When we create our classes, we don't need to explicitly inherit from
  `Object'. That is done automatically.

  ┌────
  │ class Person
  │   # This class has access to all stuff defined in
  │   # Object and Kernl.
  │   #
  │ end
  │
  │ p Person.superclass
  │ # → Object
  │
  │ p Person.class
  │ # → Class
  └────

  ┌────
  │ Object
  │ Class
  └────


  Remember that doing `class Foo ... end' is the same as `Foo =
  Class.new do ... end', and that the former notation is syntax sugar
  the latter. So, `Person' is an instance of `Class' (so `Person' is
  indeed also an object on its own right), and it inherits from
  `Object'. And `Object' mixes in the module `Kernel' Read more at [Ruby
  docs about the `Object' class].


[Ruby docs about the `Object' class]
https://ruby-doc.org/core-2.5.1/Object.html
