= Functional Programming With TypeScript
:toc: right
:icons: font
:sectlevels: 6
:sectlinks:
:source-highlighter: highlight.js
:imagesdir: __assets
:experimental:

== Intro

We'll try avoid relying on type inference most of the time and instead write explicitly type annotations for documentation purpose and also to improve our practice with types in general.

== Setup and Running

Install node:

[source,shell-session]
----
$ nvm install $(cat ./.nvmrc)
----

Then, on any new shell session:

[source,shell-session]
----
$ nvm use
----

Then, for any example to run (type “yes” the first time):

[source,shell-session]
----
$ npm install
$ npx ts-node ./src/example.ts
----

== Notes

Functions should be *total* _and_ *deterministic*.

Immutable data: create new values from old ones.

Referential transparency.

== Commits

Commit changes in this directory with the type “fpts” and a “scope” if it makes sense. Examples:

[source,shell-session]
----
$ git commit -m 'type: Subject text'
$ git commit -m 'type(scope): Subject text'

$ git commit -m 'fpts: Add first function example'
$ git commit -m 'fpts(docs): Improve readme '
----

[NOTE]
====
Of course, write the body of the commit messages as well if it makes sense for that commit.
====

== Compose

Compose a function that increments a number then turns it into a string.

[source,typescript]
----
function inc(x: number): number {
  return x + 1;
}

function toStr(x: number): string {
  return x.toString();
}

function incThenToStr(x: number) {
  return toStr(inc(x));
}
----

But the function composition is hard-coded.
It will always apply those two specific functions.
It is not _that_ helpful or reusable.
Ideally, we want a generic `compose` function.

== Compose v2

A very simple implementation where we hard-code the types `number` and `string`.
This is an initial implementation in which always exactly two functions can be composed.

[source,typescript]
----
/**
 * Applies the functions right-to left, that is, first `g`, then `f`.
 */
function compose(
  f: (x: number) => string,
  g: (x: number) => number,
): (x: number) => string {
  return function composed(x: number): string {
    return f(g(x));
  };
}

/**
 * Increments `x` then returns it as a string.
 */
const incThenStr: (x: number) => string = compose(toStr, inc);

const res1: string = incThenStr(0);
log(res1, typeof res1);
//=> 1    string
----

It is still not very generic, but now at least `f` and `g` can be _any_ function at least match the expected type contracts.
For example:

[source,typescript]
----
/**
 * Doubles `x` then returns it as a string.
 */
const doubleThenStr: (x: number) => string = compose(toStr, double);

const res2: string = doubleThenStr(7);
log(res2, typeof res2 });
//=> 14   string
----

== Compose with improved types

Notice our `g()` takes some type `T`, and returns some type `U` (`T` and `U` can be the same type, but they _don't have to_).
Then, `f` takes that type `U` and returns some type `R`.
What matters is that the return type of `g()` matches the input type of `f()` so that that the output of one function can be fed as the input of the other function.

With that in mind, we can refactor `compose()` to take generic types instead of the hard-coded `string` and `number`:

[source,typescript]
----
/**
 * Applies the functions right-to left, that is, first `g`, then `f`.
 */
function compose<T, U, R>(
  f: (x: U) => R,
  g: (x: T) => U,
): (x: T) => R {
  return function composed(x: T): R {
    return f(g(x));
  };
}
----

And our examples from earlier still work just the same.
Neat!

// // // // // // // // // // // // // // // // // // // // // // // //
// End of text. Configs from this point on.
//

++++
<style type="text/css">
.hljs-comment {
  font-style: normal;
}
</style>
++++
