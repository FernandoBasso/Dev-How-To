= Functional Programming With TypeScript
:toc: right
:icons: font
:sectlevels: 6
:sectlinks:
:source-highlighter: highlight.js
:imagesdir: __assets
:experimental:

== Setup and Running

Install node:

[source,shell-session]
----
$ nvm install $(cat ./.nvmrc)
----

Then, on any new shell session:

[source,shell-session]
----
$ nvm use
----

Then, for any example to run (type “yes” the first time):

[source,shell-session]
----
$ npm install
$ npx ts-node ./src/example.ts
----

== Notes

Functions should be *total* _and_ *deterministic*.

Immutable data: create new values from old ones.

Referential transparency.

== Commits

Commit changes in this directory with the type “fpts” and a “scope” if it makes sense. Examples:

[source,shell-session]
----
$ git commit -m 'type: Subject text'
$ git commit -m 'type(scope): Subject text'

$ git commit -m 'fpts: Add first function example'
$ git commit -m 'fpts(docs): Improve readme '
----

[NOTE]
====
Of course, write the body of the commit messages as well if it makes sense for that commit.
====

== Compose

Compose a function that increments a number then turns it into a string.

[source,typescript]
----
function inc(x: number): number {
  return x + 1;
}

function toStr(x: number): string {
  return x.toString();
}

function incThenToStr(x: number) {
  return toStr(inc(x));
}
----

But the functions composition is hard-coded.
It will always apply those two functions.
It is not _that_ helpful or reusable.
Ideally, we want a generic `compose` function.

== Compose v2

A very simple implementation where we hard-code the types `number` and `string`.

[source,typescript]
----
function toStr(v: number): string {
  return v.toString();
}

function inc(x: number): number {
  return x + 1;
}

/**
 * Applies the functions right-to left.
 */
function compose(
  g: (x: number) => string,
  f: (x: number) => number,
): (x: number) => string {
  return function composed(x: number): string {
    return g(f(x));
  };
}

/**
 * Increments `x` then returns it as a string.
 */
const incThenStr = compose(toStr, inc);

const res1: string = incThenStr(0);
log(res1, typeof res1);
//=> 1    string
----

It is still not very generic, but now at least `f` and `g` can be _any_ function at least match the expected type contracts.
For example:

[source,typescript]
----
/**
 * Doubles `x` then returns it as a string.
 */
const doubleThenStr: (x: number) => string = compose(toStr, double);

const res2: string = doubleThenStr(7);
log(res2, typeof res2 });
//=> 14   string
----



// // // // // // // // // // // // // // // // // // // // // // // //
// End of text. Configs from this point on.
//

++++
<style type="text/css">
.hljs-comment {
  font-style: normal;
}
</style>
++++
