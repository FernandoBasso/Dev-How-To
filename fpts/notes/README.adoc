= Functional Programming With TypeScript
:toc: right
:icons: font
:sectlevels: 6
:sectlinks:
:source-highlighter: highlight.js
// :source-highlighter: pygments
// :source-highlighter: rouge
:imagesdir: __assets
:stem: latexmath
:experimental:

== Intro

These are some notes, concepts and examples on functional programming with TypeScript.

We'll try avoid relying on type inference most of the time and instead write explicit type annotations for documentation purpose and also to improve our practice with types in general.

There are many reasons to avoid relying on type inference as a default approach, but we'll leave that to be discussed elsewhere.

== Setup and Running

Install node:

[source,shell-session]
----
$ nvm install $(cat ./.nvmrc)
----

Then, on any new shell session:

[source,shell-session]
----
$ nvm use
----

Then, for any example to run (type “yes” the first time):

[source,shell-session]
----
$ npm install
$ npx ts-node ./src/example.ts
----

== AsciiDoc

On Firefox, install the extension link:https://addons.mozilla.org/en-US/firefox/addon/asciidoctorjs-live-preview/[Asciidoctor.js Live Preview Extension^] then simply open `README.adoc` on Firefox.

Alternatively, install `asciidoctor` and a few other ruby gems and generate the HTML and PDF files:

[source,shell-session]
----
$ gem install asciidoctor asciidoctor-pdf pygments.rb
$ asciidoctor -a source-highlighter=pygments ./README.adoc
$ asciidoctor-pdf -a source-highlighter=pygments ./README.adoc
----

Then open `README.html` or `README.pdf`.

== Notes

Functions should be *total* _and_ *deterministic*.

Immutable data: create new values from old ones.

Referential transparency.

== Commits

Commit changes in this directory with the type “fpts” and a “scope” if it makes sense. Examples:

[source,shell-session]
----
$ git commit -m 'type: Subject text'
$ git commit -m 'type(scope): Subject text'

$ git commit -m 'fpts: Add first function example'
$ git commit -m 'fpts(docs): Improve readme '
----

[NOTE]
====
Of course, write the body of the commit messages as well if it makes sense for that commit.
====

== Compose

Compose a function that increments a number then turns it into a string.

[source,typescript]
----
function inc(x: number): number {
  return x + 1;
}

function toStr(x: number): string {
  return x.toString();
}

function incThenToStr(x: number) {
  return toStr(inc(x));
}
----

But the function composition is hard-coded.
It will always apply those two specific functions.
It is not _that_ helpful or reusable.
Ideally, we want a generic `compose` function.

== Compose v2

A very simple implementation where we hard-code the types `number` and `string`.
This is an initial implementation in which always exactly two functions can be composed.

[source,typescript]
----
/**
 * Applies the functions right-to left, that is, first `g`, then `f`.
 */
function compose(
  f: (x: number) => string,
  g: (x: number) => number,
): (x: number) => string {
  return function composed(x: number): string {
    return f(g(x));
  };
}

/**
 * Increments `x` then returns it as a string.
 */
const incThenStr: (x: number) => string = compose(toStr, inc);

const res1: string = incThenStr(0);
log(res1, typeof res1);
//=> 1    string
----

It is still not very generic, but now at least `f` and `g` can be _any_ function at least match the expected type contracts.
For example:

[source,typescript]
----
/**
 * Doubles `x` then returns it as a string.
 */
const doubleThenStr: (x: number) => string = compose(toStr, double);

const res2: string = doubleThenStr(7);
log(res2, typeof res2 });
//=> 14   string
----

== Compose with improved types

Notice our `g()` takes some type `T`, and returns some type `U` (`T` and `U` can be the same type, but they _don't have to_).
Then, `f` takes that type `U` and returns some type `R`.
What matters is that the return type of `g()` matches the input type of `f()` so that that the output of one function can be fed as the input of the other function.

With that in mind, we can refactor `compose()` to take generic types instead of the hard-coded `string` and `number`:

[source,typescript]
----
/**
 * Applies the functions right-to left, that is, first `g`, then `f`.
 */
function compose<T, U, R>(
  f: (x: U) => R,
  g: (x: T) => U,
): (x: T) => R {
  return function composed(x: T): R {
    return f(g(x));
  };
}
----

And our examples from earlier still work just the same.
Neat!

== Currying

In functional programming, functions receive _one_ input and produce _one_ return value (even if it is a collection being returned, we consider it to be _one_ thing).
Functions that take one argument are the so called _unary_ functions, and their _arity_ is _one_.

Considering _referential transparency_, one could say that functions are aliases for their body definitions.

This next `add` function is _not_ unary.
It takes two input parameters:

[source,typescript]
----
function add(x: number, y: number): number {
  return x + y;
}

log(add(1, 2));
//=> 3
----

Note to use this function we pass both parameters at once.
This is the normal, standard way in almost all non functional programming languages, or languages that don't support currying.
The above `add()` function takes two parameters.

But then, contrast with this:

[source,typescript]
----
function add(x: number): (y: number) => number {
  return function addY(y: number): number {
    return x + y;
  };
}

const res: number = add(1)(2);
//                  ---------
//                       \
//                        \
//                         v
//           Note the way we call add() now!
////

log(res);
//=> 3
----

Note that with this approach we first take an `x`, and return a function that takes an `y`, and finally compute and return the result.
This approach is possible thanks to ECMAScript _closures_.

Each function now takes a single parameter at a time, and returns another function that returns the next parameter.

We could call this “_manual currying_”, as we need to use the syntax `fn(a)(b)` which forces us to call functions in the `()()` fashion.

[NOTE]
====
We'll study a more interesting and currying implementation later which will make curried functions more practical to use.
====

But we already have some ways to make more specialized functions from our generic, curried `add()` function.
For example, in Haskell, we have `succ` and `pred`:

[source,text]
----
$ ghci

λ> succ 10
11

λ> pred 10
9
----

We can use `add()` to create similar implementations of `succ` and `pred` in ECMAScript:

[source,typescript]
----
/**
 * Like Haskell succ and pred functions!
 */
const succ: (n: number) => number = add(1);
const pred: (n: number) => number = add(-1);

log(succ(10));
//=> 11

log(pred(10));
//=> 9
----

We call `add()` with one parameter, which causes it to return another function that is waiting for the final argument.

We call this _partial application_.
We define a _curried function_, and then we can _partially apply_ it to only some of its arguments, causing it to return yet another function.
When all the expected arguments have been provided by successively calling each function in turn with its expected argument (remember our functions are _unary_ when talking about curring), then it returns the final result!

== curry2 utility

Instead of creating `add()` with manual currying, let's create a `curry2()` function that takes a function of arity 2 (two arguments), and returns a curried version of that function.

Initially, let's consider a non-generic typed function that takes and returns numbers:

[source,typescript]
----
//
// A type alias just for fun.
//
type Num = number;

/**
 * A utility that knows how to curry a function of arity 2.
 */
function curry2(f: (x: Num, y: Num) => Num) {
  return function withArg1(a: Num): (b: Num) => Num {
    return function withArg2(b: Num): Num {
      return f(a, b);
    };
  };
}

const add2 = curry2(add);

//
// Call add2 with one param, which returns a function that takes
// the other param, which in turn returns the final result.
//
log(add2(1)(2));
//=> 3
----

The above typing is too specific and only works for numbers.
Let's use generic and make it take any types:

[source,typescript]
----
/**
 * A utility that knows how to curry a function of arity 2.
 */
function curry2<T, U, R>(f: (x: T, y: U) => R) {
  return function withArg1(a: T): (b: U) => R {
    return function withArg2(b: U): R {
      return f(a, b);
    };
  };
}

/**
 * A standard add function of arity 2 that adds two numbers.
 */
function add(x: number, y: number): number {
  return x + y;
}

/**
 * A standard function concat of arity 2 that concatenates two strings.
 */
function concat(s1: string, s2: string): string {
  return `${s1}${s2}`;
}

const add2 = curry2(add);
const concat2 = curry2(concat);

log(add2(1)(2));
//=> 3

log(concat2("ECMA")("Script"));
//=> ECMAScript
----

In the examples, we are able to curry functions of arity two of numbers and strings, but it would work with any other type.

For the sake of exemplifying a different implementation (which yields the same result), we could define the type separately and then use it to implement `curry2()` with an arrow function:

[source,typescript]
----
type Curry2 = <T, U, R>(f: (t: T, u: U) => R)
  => (t: T)
  => (u: U)
  => R;

const curry2: Curry2 = f => x => y => f(x, y);
----

[NOTE]
====
Arrow functions are neither better nor were they created to deprecate or replace standard function statements or function expressions created with the `function` keyword.
They were created to address specific use cases, that's all.
====

== Recursion

=== Approach 1

An example `sum()` function implemented with recursion:

[source,typescript]
----
function sum(xs: number[]): number {
  if (xs.length === 0) return 0;
  return xs[0] + sum(xs.slice(1));
}

log(sum([]));
//=> 0

log(sum([-1, -2, -3]));
//=> -6
----

=== Approach 2 with destructuring

A more idiomatic way of implementing it could be with destructuring the first element and the rest first before recursing:

[source,typescript]
----
function sum(xs: number[]): number {
  if (xs.length === 0) return 0;
  const [head, ...rest] = xs;
  return head + sum(rest);
}

log(sum([]));
//=> 0

log(sum([-1, -2, -3]));
//=> -6
----

=== Approach 3 with go pattern and tail call syntax

Or using the _go pattern_, which is a nested function that then handles an accumulator.
This approach would conform to the _tail call_ recursion idea.
*Except* ECMAScript (at least as of 2024) does not support tail call optimization so even though the syntax of the next example _looks_ like tail call, it doesn't actually result in any performance benefits and the call stack keeps growing as if no tail call style had been used.

[source,typescript]
----
function sum(nums: number[]): number {
  return (function go(acc: number, xs: number[]): number {
    if (xs.length === 0) return acc;
    const [x, ...restOfXs] = xs;
    return go(acc + x, restOfXs);
    //        <1>
  })(0, nums);
}

log(sum([]));
//=> 0

log(sum([-1, -2, -3]));
//=> -6
----

<1> Here, `acc + x` means we are immediately computing the next value of the accumulator, without enqueueing that computation and and next recursion call as a new frame (but as mentioned, it doesn't do any good in ECMAScript any way).

[NOTE]
====
Tail call happens when the recursion call is the last thing executed in the body of the function, which allows language compilers to optimize and return the new computed value immediately for the next recursive call instead of keeping adding frames to the call stack until the base case is reached.

Without tail call, frames keep being added to the stack, and there is an _unwinding_ phase where the final computation of the values is performed.
With tail call, no frames are added to the stack (so no stack overflows) and there is no need for the _unwinding_ phase.
====

The `sum()` function returns 0 (zero) for the empty array input because 0 (zero) is the identify for addition and subtraction (1 is the identity for multiplication and division).
Adding or subtracting 0 from a stem:[x] produces stem:[x], the same as multiplying or dividing stem:[x] also produces stem:[x].



// // // // // // // // // // // // // // // // // // // // // // // //
// End of text. Configs from this point on.
//

++++
<style type="text/css">
.hljs-comment {
  font-style: normal;
}
</style>
++++
