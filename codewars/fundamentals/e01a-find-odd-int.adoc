= Find Odd Integer | CodeWars Challenge
// :linkcss:
// :stylesheet: asciidoctor-original-with-overrides.css
// :stylesdir: {user-home}/Projects/proghowto
:webfonts:
:icons!: font
:stem: latexmath
:source-highlighter: pygments
:source-linenums-option:
:pygments-css: class
:sectlinks:
:sectnums:
:toclevels: 6
:toc: left
:favicon: https://fernandobasso.dev/cmdline.png



https://www.codewars.com/kata/54da5a58ea159efa38000836/train/javascript

ASSUME: Input array composed of only integers.

ASSUME: There will always be only one integer that appears an odd number of times.

----
findOdd([20, 1, -1, 2, -2, 3, 3, 5, 5, 1, 2, 4, 20, 4, -1, -2, 5]);
// → 5;

findOdd([1, 1, 2, -2, 5, 2, 4, 4, -1, -2, 5]);
// → -1

findOdd([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]);
// → 5

findOdd([10]);
// → 10

findOdd([1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1]);
// → 10

findOdd([5, 4, 3, 2, 1, 5, 4, 3, 2, 10, 10]);
// → 1
----


== JavaScript

=== Solution 1

[source,javascript,lineos]
----
// findOdd :: array<number> -> number
function findOdd(arr) {
  const obj = arr.reduce((acc,  n) => {
    if (acc[n] === undefined) {
      acc[n] = 1;
      return acc;
    }

    acc[n] += 1;
    return acc;
  }, {});

  return Object.keys(obj).find(k => obj[k] % 2 !== 0);
}
----

Create an object where each number is the key, and we increment the value for that key every time that number appears. Then, find which key in the object has an odd number as its value.


=== Solution 2

[source,javascript,lineos]
----
// findOdd :: array<number> -> number
function findOdd(arr) {
  return arr.find(n => arr.filter(e => e === n).length % 2 !== 0);
}
----

For each number latexmath:[n] in the array, filter the array where that number latexmath:[n] appears an odd number of times.

=== Solution 3

[source,javascript,lineos]
----
// findOdd :: array<number> -> number
const findOdd = arr => arr.reduce((acc, n) => acc ^ n);
----


1. XORing latexmath:[x] latexmath:[epilson] and to itself yields 0.

    1 ^ 1 = 0
    1 ^ 1 ^ 1 ^ 1 = 0


2. XORing x to 0 yields x.

    1 ^ 0 = 1
    5 ^ 0 = 5


If we XOR x an even number of times, the result is always 0. It means an
even number of x's cancel themselves.

For this challenge, since it is ASSUMED that there will be only one number
that appears an even number of times, we can use this bitwise XOR technique
to obtain the answer.

    1 ^ 1 ^ 3 = 3
    1 ^ 2 ^ 1 ^ 2 ^ 3 = 3

The XOR operator has the associative and commutative properties. Thus, the
order of the numbers in the array doesn't matter for this case.

https://en.wikipedia.org/wiki/Exclusive_or#Properties

Of course, the reducer's accumulator is cleverly used here too!

