= Bash Strings
:linkcss!:
:webfonts!:
:icons!: font
:source-highlighter: pygments
:pygments-css: style
:sectlinks:
:toc: left

== Importance of Quoting

CAUTION: The “space” character is very important in Bash (and other shells). It delimits tokens.

link:https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Quoting[Bash man page section on Quoting^]


=== Basic Examples

Here, `echo` is being given three arguments to print:

[source,sh]
----
echo may the force
----

And here, `printf` is being given one _format specifier_ (`%s`) and _three arguments_. The format specifier is reused until all arguments all consumed.

[source,sh]
----
printf '%s\n' be with you.
----

The above is the same as:

[source,sh]
----
printf '%s\n' be
printf '%s\n' with
printf '%s\n' you.
----


== Escape Character

=== Example 1 - Printing

.Example
[source,bash]
----
echo foo\
    bar
----

.Output
[source,plain]
----
foo bar
----

The unquoted escape removes the newline. We are left with `foo␠␠␠␠bar`. That is two arguments. `echo` prints those arguments separated by a single whitespace.

.Excerpt from `help echo'
----
$ help echo
echo: echo [-neE] [arg ...]
    Write arguments to the standard output.

    Display the ARGs, separated by a single space character and followed by a
    newline, on the standard output.
----

=== Example 2 - Assignment

However, the same syntax doesn't work for an assignment expression:

.Example
[source,bash]
----
str=foo\
    bar
----

.Output
----
$ bash dev.sh
dev.sh: line 2: bar: command not found
----

And the reason why link:https://lists.gnu.org/archive/html/help-bash/2019-09/msg00012.html[was explained^] by no one less than the most honorable Greg Wooledge The First.

In short, it becomes this:

.Example on how it is interpreted
[source,sh]
----
str=foo bar
----

That is, we create an environment variable `str=foo` for the command `bar`. Can be checked with this:

.Proof of the description above
[source,plain]
----
$ str=foo\
>  printenv str
foo
----

We indeed create an environment variable `str` with the value “foo” for the current command.

== Single vs Double Quotes


=== Quoting - Example 1

Note we quote neither the string being assigned to `str` nor the variable passed to `printf`.

[source,sh]
----
str=The force is strong with this one.
----

[source,sh]
----
script.sh: line 1: force: command not found
----

The problem is that the shell assigns 'The' to `str`, sees the space, assumes it is separating the token 'The' from the token 'force', and terminates the assignment. It then assumes the next token, “force” is a command, and thus the error.

In short, we are setting the environment variable `str=The` for the command `force`, and the remaining words would become the arguments to the command. Since `force` is not a real command or program (on my system, at least), the error occurs.

With the above, we can then understand why these two next examples produce they output observed.

[source,plain]
----
$ str=The echo is strong with this one.
is strong with this one.

$ str=The printf '%s\n' is strong with this one.
is
strong
with
this
one.
----

In both cases, we create an environment variable (which is not even used) `str=The`. Then there is the `echo` and `printf` commands. `echo` prints any arguments passed, and ``printf``'s format specifier is used as many times as needed to consume all arguments.


=== Quoting - Example 2

We can “quote” values either by using single quotes, double quotes, or escaping the spaces and other especial characters. Each of the three strings below is assigned as a single value to the heir corresponding variable:

[source,sh]
----
s1=foo\ bar
s2='foo bar'
s3="foo bar'
----

In all three cases, the space character is made literal and does not cause the shell to interpret it as a token separator.

So, we try the next example proper:

[source,sh]
----
str='The force is strong with this one.'
printf '%s\n' $str # <1>
----

And we see this output:

.output
----
$ bash script.sh
The
force
is
strong
with
this
one.
----

<1> Note we did not quote `$str`. Therefore, the shell does _word-splitting_ and `printf` receives several arguments, which it prints according to the format specifier `%s\n` thus, each word on its own line.


== Links and Resources

- http://oliviercontant.com/why-is-printf-better-than-echo-in-shell-scripting/


