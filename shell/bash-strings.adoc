= Bash Strings
:linkcss!:
:webfonts!:
:icons!: font
:source-highlighter: pygments
:pygments-css: style
:sectlinks:
:toc: left

== Importance of Quoting

CAUTION: The “space” character is very important in Bash (and other shells). It delimits tokens.

link:https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Quoting[Bash man page section on Quoting^]


== Escape Character

=== Example 1 - Printing

.Example
[source,bash]
----
echo foo\
    bar
----

.Output
[source,plain]
----
foo bar
----

It prints `foo bar` because the backslash after “foo” is not itself quoted. Therefore, it removes the meaning of the newline created when pressing Enter. Also, We see only one space between the output “foo” and “bar” because since nothing was quoted, all the spaces the between the tokens “foo” and “bar” are considered one one single word separator, and `echo` prints its arguments one by one, separated by a space between each.

.Excerpt from `help echo`
----
$ help echo
echo: echo [-neE] [arg ...]
    Write arguments to the standard output.

    Display the ARGs, separated by a single space character and followed by a
    newline, on the standard output.
----

=== Example 2 - Assignment

However, the same syntax doesn't work for an assignment expression:

.Example
[source,bash]
----
str=foo\
    bar
----

.Output
----
$ bash dev.sh
dev.sh: line 2: bar: command not found
----

And link:https://lists.gnu.org/archive/html/help-bash/2019-09/msg00012.html[here's a great explanation on why that is^], by the most honorable Greg Wooledge The First.

In short, it becomes this:

.Example on how it is interpreted
[source,bash]
----
str=foo bar
----

That is, we create an environment variable `str=foo` for the command `bar`. Can be checked with this:

.Proof of the description above
[source,plain]
----
$ str=foo\
>  printenv str
foo
----

We indeed create an environment variable `str` with the value “foo” for the current command.

== Single vs Double Quotes



=== Quoting - Example 1

Note we quote neither the string being assigned to `str` nor the variable passed to `printf`.

```bash
str=The force is strong with this one.
printf '%s\n' $str
```

```
script.sh: line 1: force: command not found
```

The problem is that the shell assigns 'The' to `str`, sees the space, assumes it is separating the token 'The' from the token 'force', and terminates the assignment. It then assumes the next token, “force” is a command, and thus the error.

In short, it assumes we are setting the environment variable `str=The` for the command `force`, and the remaining words would become the arguments to the command. Since `force` is not a real command or program (on my system, at least), the error occurs.

=== Quoting - Example 2

We can “quote” values either by using single quotes, double quotes, or escaping the spaces. Each of the three strings below is assigned as a single value to the heir corresponding variable:

```bash
s1=foo\ bar
s2='foo bar'
s3="foo bar'
```

In all three cases, the space character is made literal and does not cause the shell to interpret it as a token separator.

So, we try the next example proper:

```bash
str=The force is strong with this one.
printf '%s\n' $str # <1>
```

And we see this output:

```
$ bash script.sh
The
force
is
strong
with
this
one.
```

<1> Note we did not quote `$str`. Therefore, `printf` does _word-splitting_ and prints each word on a new line, as instructed by the format specifier `%s\n`.


== Links and Resources

- http://oliviercontant.com/why-is-printf-better-than-echo-in-shell-scripting/
