#+TITLE: More Functional Patterns - ch07 - Haskell From First Principles
#+AUTHOR: Fernando Basso <fernandobasso.br@gmail.com>

* Make it func-y

*Function*: instruction to produce output from an input. Functions are applied t o arguments which binds their parameters to values. The fully applied function with its arguments is then evaluated to produce the output or result.

Haskell functions are first-class entities that:

- can be values in expressions, lists, or tuples;
- can be passed as arguments to a function;
- can be returned from a function as a result;
- make use of syntactic patterns.

* Arguments and parameters

Functions may appear to take multiple arguments, but that is just syntax sugar. Functions in Haskell always take only a single a argument and return one result. Functions are _defined_ by the fact that they can be applied to an argument to produce a result.

All Haskell values can be arguments to functions. A value that can be used as an argument to a function is a _first-class_ value. Functions are first-class values in Haskell.

#+begin_src haskell
myNum :: Integer
myNum = 1
#+end_src

~myNum~ _is_ an Integer of the value 1.

#+begin_src haskell
myVal f x = f x
#+end_src

#+begin_example
λ> myNum :: Int ; myNum = 1
λ> :t myNum
myNum :: Int
λ> myVal f = f myNum
λ> :t myVal
myVal :: (Int -> t) -> t
#+end_example

Now ~myVal~ is a function, because it takes a function ~(Int -> t)~ and returns a ~t~.

Here, ~f~, ~g~ and ~h~ are infered the most generic possible because nothing is known about them. If they were applied to a value, something would have become known about them, though.

#+begin_example
λ> myVal f g h = myNum
λ> :t myVal
myVal :: p1 -> p2 -> p3 -> Int
#+end_example




