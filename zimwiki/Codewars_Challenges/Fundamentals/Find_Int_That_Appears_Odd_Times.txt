Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-05-23T15:37:14-03:00

====== Find Int That Appears Odd Times ======
Created Saturday 23 May 2020

Find the int that appears an odd number of times.

===== Links =====
* https://www.codewars.com/kata/54da5a58ea159efa38000836


===== Solutions =====

==== JavaScript ====

=== lengthy reduce, Object.keys find ===
'''
/**
 * @param {number[]} arr
 * @return {number|undefined|string}
 */
function findOdd(arr) {
  const obj = arr.reduce((acc,  n) => {
    // If we have not yet started counting the number of
    // appearances of that number...
    if (acc[n] === undefined) {
      // ...then make that an index with value of 1.
      acc[n] = 1;
      return acc;
    }

    // We have seen this number before. Increment its “count” value.
    acc[n] += 1;
    return acc;
  }, {});

  return Object.keys(obj).find(k => obj[k] % 2 !== 0);
}
'''


=== find filter lenght odd ===

'''
function findOdd(arr) {
  // ‘filter’ filters all ‘e’s that are equal to ‘n’ and then verifies
  // that the resulting filtered array has an odd ‘length’.
  return arr.find(n => arr.filter(e => e === n).length % 2 !== 0);
}
'''


=== bitwise XOR ===

'''
/**
 * @param {number]]} arr
 * @return {number}
 */
const findOdd = arr => arr.reduce((acc, n) => acc ^ n);
'''

NOTE: This is my own explanation.

XORing ‘x’ to itself and even number of times always yields 0.
'''
1 ^ 1 = 0
1 ^ 1 ^ 1 ^ 1 = 0
'''

XORing x to 0 yields x.
'''
1 ^ 0 = 1
5 ^ 0 = 5
'''

If we XOR x an even number of times, the result is always 0. It means an even number of ‘x’'s cancel themselves.

For this challenge, since it is ASSUMED that there will be only one number that appears an even number of times, we can use this bitwise XOR technique to obtain the answer.

'''
1 ^ 1 ^ 3 = 3
1 ^ 2 ^ 1 ^ 2 ^ 3 = 3
'''

The XOR operator has the associative and commutative properties. Thus, the order of the numbers in the array doesn't matter for this case.

* https://en.wikipedia.org/wiki/Exclusive_or#Properties

The reducer's accumulator is cleverly used in this solution!

==== Ruby ====

=== method ===

'''
def find_n(nums)
  nums.find do |n|
    nums.collect do |i|
      i == n
    end.length.odd?
  end
end
'''


=== lambda ===

'''
find_n = lambda do |nums|
  nums.find do |n|
    nums.collect do |i|
      i == n
    end.length.odd?
  end
end
'''

REMEMBER: Lambdas must be called with ‘call’ or ‘.()’.

=== detect, count ===

'''
def find_n(nums)
  nums.detect { |n| nums.count(n).odd? }
end
'''

NOTE: ‘find’ is an alias for ‘detect’. See more [[Programming:Ruby:Ruby Aliases|Ruby Aliases]].

=== reduce, bitewise XOR ===

'''
find_n = lambda { |xs| xs.reduce(:^) }
'''


==== Scheme ====

=== single function ===
'''
(define find-n
  (lambda (xs)
    (find (lambda (x)
            (odd?
             (length
              (filter (lambda (i)
                        (= x i))
                      xs))))
          xs)))
'''


=== helper functions ===

'''
;; Collects all ‘val’s from the list ‘xs’.
(define collect-val
  (lambda (val xs)
    (filter (lambda (x) (= val x)) xs)))

;; Checks whether ‘xs’ length is odd.
(define odd-len?
  (lambda (xs)
    (odd? (length xs))))

;; Find int that appears an odd number of times in ‘xs’.
;; Using ‘odd-len?’ and ‘collect-val’ helpers.
(define find-n
  (lambda (xs)
    (find (lambdx (x)
            (odd-len? (collect-x x xs)))
          xs)))
'''


==== TypeScript ====

=== Unnecessarily lengthy ===

'''
interface KVObj {
  [name: number]: number;
}

const findInt = function findInt (nums: number[]): number | undefined {
  const obj: KVObj = nums.reduce((acc: KVObj, n: number) => {
    if (acc[n] === undefined) {
      acc[n] = 1;
      return acc;
    }

    acc[n] += 1;
    return acc;
  }, {});

 return Object.keys(obj)
    .map(Number)
    .find(k => obj[k] % 2 !== 0);
};
'''

With ‘find’ we cannot be sure it'll find the thing we are looking for, therefore we either do something before returning or make our function return ‘number | undefined’ to satisfy the type checker.

=== find, filter ===

'''
function findInt(nums: number[]): number | undefined {
  return nums.find(n => nums.filter(i => i === n).length % 2 !== 0);
};
'''


=== bitwise XOR ===

'''
function findInt(nums: number[]): number {
  return nums.reduce((acc, num) => acc ^ num);
};
'''

This solution never returns ‘undefined’. If an odd integer is not found, it will return ‘0’ (because if the bitwise XORing), which is probably an incorrect answer. So, we must assume zero will never be the “the int that appears an odd number of times.”

XORing x to itself an even number of times always yields 0.
'''
1 ^ 1 = 0
1 ^ 1 ^ 1 ^ 1 = 0
'''

XORing x to 0 yields x.
'''
1 ^ 0 = 1
5 ^ 0 = 5
'''

If we XOR x an even number of times, the result is always 0. It means an even number of src_example][]{x}'s cancel themselves.

For this challenge, since it is ASSUMED that there will be only one number that appears an even number of times, we can use this bitwise XOR technique to obtain the answer.
'''
1 ^ 1 ^ 3 = 3
1 ^ 2 ^ 1 ^ 2 ^ 3 = 3
'''

The XOR operator has the associative and commutative properties. Thus, the order of the numbers in the array doesn't matter for this case.

* https://en.wikipedia.org/wiki/Exclusive_or#Properties

Of course, the reducer's accumulator is cleverly used here too!

===== The End =====



