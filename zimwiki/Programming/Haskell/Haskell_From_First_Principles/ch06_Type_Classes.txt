Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-01-29T14:49:01-03:00

====== ch06 Type Classes ======
Created Wednesday 29 January 2020

===== What are type classes? =====

Type classes and types are, in some sense, opposites.

* Declaration of a type: how a type is created.
* Declaration of a type class: how a set of types are consumed/used in computations.

Type classes are like interfaces in other languages. Type classes are a means of ad-hoc (constrained) polymorphism because code is dispatched by type.

No need different ‘==’ and ‘/=’ functions for each type of data. As long as the type implements ‘Eq’, we can use those functions with that type.

===== Back to Bool =====

‘:info Bool’ displays the data declaration for ‘Bool’ and which
type classes it already has instances of.

'''
λ> :info Bool
data Bool = False | True
instance Eq Bool
instance Ord Bool
instance Show Bool
instance Read Bool
instance Enum Bool
instance Bounded Bool
'''


Q:
Is ‘Bool’ a type or a type class‽

A:
‘Bool’ is a type, and it has instances of type classes like ‘Eq’, ‘Ord’, ‘Show’, ‘Bounded’, etc.

The type class instances that ‘Bool’ implements are unique specifications of how ‘Bool’ makes use of the methods from each of those type classes.

'''
λ> minBound
()
λ> maxBound
()
λ> minBound :: Bool
False
λ> maxBound :: Bool
True
λ> minBound :: Integer
-9223372036854775808
λ> maxBound :: Int
9223372036854775807
'''

--------------------
Q: Why ‘minBound :: Integer’ throws an error?

A:
Because the type ‘Integer’ does not have an instance of ‘Bounded’. See with ‘:info Integer’.

--------------------

Type classes have a hierarchy of sorts. All Fractional numbers implement the ‘Num’ type class, but not all members of ‘Num’ are ‘Fractional’. All members of ‘Ord’ must be members of ‘Eq’, and all members of ‘Enum’ must be members of ‘Ord‘. To be able to put things into an enumerated list, they must be orderable; to be orderable, they must be able to be compared for equality.

===== Eq =====

Not all objects can be compared for equality, functions being one such case.

'''
λ> :info Eq
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  {-# MINIMAL (==) | (/=) #-}
'''

‘class Eq’ here means a “type class”.

--------------------
Q:

'''
λ> (==) 'z'
'''

Why partially-applying ‘==’ above produces an error?

A:
Because it produces a function, and functions do not implement ‘Show’. It works if we store the result in a variable. It is not partially-applying it that produces an error, but trying to print the resulting function.

NOTE: It works on Emacs haskell-mode REPL. It must be doing something funny behind the scenes, like merijn@haskell-beginners infered (pun intended), “Seems like the error handling/printing logic is overridden.”


--------------------

The type of a type variable is usually set by the left-most argument. In ‘x == y’, if ‘x’ is an ‘Int’, ‘y’ must be an ‘Int’ too.

'''
λ> :t (==)
(==) :: Eq a => a -> a -> Bool
λ> :t (==) 'z'
(==) 'z' :: Char -> Bool
'''

So, ‘==’ is type-class-constrained by ‘Eq’. When we partially-apply it to a concrete type, the type class constraint ‘Eq’ is dropped because it is redundant, since ‘Char’ has an instance of it.

'''
λ> :info (,)
data (,) a b = (,) a b
instance (Eq a, Eq b) => Eq (a, b)
'''

The equality of two tuples depend on the equality of their constituent values! Note the ‘Eq a’ and ‘Eq b’ stuff! Tuples can be compared if their individual values can be compared.

--------------------
Q: What are some type classes one can magically derive? What does “deriving” mean‽

A:
We can magically derive ‘Eq’, ‘Ord’, ‘Enum’, ‘Bounded’, ‘Read’, and ‘Show’.

“Deriving” means one doesn't have to manually write instances of those type casses for each new datatype one creates.

--------------------

===== Writting type class instances =====

Data types vs type classes.

Data types are types. Type classes are like interfaces. Types have instances of type classes.

In the [[http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html|Eq docs]], it reads: “Minimal complete definition: either ‘==’ or ‘/=’.” It means we don't need to define both because one can be defined as a negation of the other.

Data constructors and type constructors often have the same name.

The keyword ‘instance’ begins a declaration of a type class instance.

'''
data Trivial = Foo | Bar

instance Eq Trivial where
  Foo == Foo = True
  Bar == Bar = True
  _   == _   = False
'''

‘Trivial’ is the type, and we are also implementing an instance of ‘Eq’ type class for the ‘Trivial’ type. We can now say that ‘Trival’ has an instance of ‘Eq’.

You can’t have two type class instances for the same type. Type class instances are unique for a given type.

==== Partial Functions ====

PARTIAL FUNCTION: a function that does not handle all possible inputs.

'''
data Thing = Foo | Bar
  deriving Show

instance Eq Thing where
  (==) Foo Foo = True
'''

'''
λ> :set -Wall
λ> :load dev.hs
[1 of 1] Compiling Main             ( dev.hs, interpreted )

dev.hs:7:3: warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘==’:
        Patterns not matched:
            Foo Bar
            Bar _
  |
7 |   (==) Foo Foo = True
  |   ^^^^^^^^^^^^^^^^^^^
Ok, one module loaded.
λ> Foo == Foo
True
λ> Bar == Foo
*** Exception: dev.hs:7:3-21: Non-exhaustive patterns in function ==

'''
The problem is that we did not handle ‘Bar’ in the ‘Eq’ instance for ‘Thing’. Fix:

'''
instance Eq Thing where
  (==) Foo Foo = True
  (==) Bar Bar = True
  (==) _   _   = False
'''

Another example of a partial function:

'''
f :: Int -> Bool
f 1 = False
'''

What about when the input to the function isn't 1? Could do it like this, prehaps:

'''
f :: Int -> Bool
f 0 = True
f _ = False
'''


'''
instance Eq (Identity a) where
  (==) (Identity v) (Identity v') = v == v'
'''

Impossible to be sure that ‘a’ has an instance of ‘Eq’. GHC errors out. We can type-class-constrain ‘a’, though.

'''
instance Eq a => Eq (Identity a) where
  (==) (Identity v) (Identity v') = v == v'
'''


===== Num =====

'''
λ> :info Integral
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
  {-# MINIMAL quotRem, toInteger #-}
        -- Defined in ‘GHC.Real’
instance Integral Word -- Defined in ‘GHC.Real’
instance Integral Integer -- Defined in ‘GHC.Real’
instance Integral Int -- Defined in ‘GHC.Real’
'''

Any type that has an instance of ‘Integral’ must also have an instance of ‘Real’ and ‘Enum’, and ‘Real’ itself requires an instance of ‘Num’. The inheritance thing in Haskell is **only** __additive__. That is, ‘Real’ cannot override the methods inherited from ‘Num’ nor can ‘Integral’ override the functions inherited from ‘Real’ and/or ‘Enum’. Therefore Haskell avoids the ambiguity problems — the so-called “deadly diamond of death” — caused by multiple inheritance in some programming languages.


===== Type-defaulting type classes =====

**NOTE**: type defaulting produces warnings with ‘-Wall’.

When you have a type class-constrained (ad hoc), polymorphic value and need to evaluate it, the polymorphism must be resolved to a specific concrete type. The concrete type must have an instance for all the required type class instances (that is, if it is required to implement ‘Num’ and ‘Fractional’, then the concrete type can’t be an ‘Int’).

‘1 / 2’ produces 0.5 and defaults to ‘Double’. We can explicitly make it another, non-default, type:

'''
λ> 1 / 2 :: Float
0.5
λ> 1 / 2 :: Double
0.5
λ> 1 / 2 :: Rational
1 % 2
'''

The Haskell Report specifies the defaults:

'''
default Num Integer
default Real Integer
default Enum Integer
default Integral Integer
default Fractional Double
default RealFrac Double
default Floating Double
default RealFloat Double
'''

So, when a concrete type is not explicitly specified, these defaults are used.

Functions from ‘Num’ get specialized when applied to more monomorphic, concrete types:

'''
λ> :type (+) (1 :: Int)
(+) (1 :: Int) :: Int -> Int
'''

Or we can create specialized, monomorphic versions:

'''
λ> add = (+) :: Word -> Word -> Word
λ> :t add
add :: Word -> Word -> Word
λ> add 0 1
1
λ> add 0 (-1)

<interactive>:40:9: warning: [-Woverflowed-literals]
    Literal -1 is out of the Word range 0..18446744073709551615
18446744073709551615
'''

But we CANNOT make more generic, polymorphic versions from more monomorphic, specific ones. Types can be made more specific, but they cannot be made more general or polymorphic.

===== Ord =====

'''
λ> :info Ord
λ> :info Ordering
λ> :info compare
'''

‘<’, ‘>’, ‘>=’, and ‘<=’ return ‘Bool’. ‘compare’ returns ‘Ordering’.

==== Enum ====

‘Enum’ type class covers types that are enumerable, that is, their values have known predecessors and successors.

‘enumFromThenTo’ starts from arg1, then in steps of ‘arg2 - arg1’, up to ‘arg3’.

==== Show ====

GHCi uses ‘Show’ to generate String values it can print in the terminal. ‘Show’ is not a serialization format. Serialization is how data is rendered to a textual or binary format for persistence or communicating with other computers over a network. An example of persistence would be saving data to a file on disk. ‘Show’ is not suitable for any of these purposes; it’s expressly for human readability.

Haskell manages effects by separating effectful computations from pure computations in ways that preserve the predictability and safety of function evaluation. Importantly, effect-bearing computations themselves become more composable and easier to reason about.

'''
λ> :type print
print :: Show a => a -> IO ()
'''

That is, ‘print’ takes an ‘a’ and returns an ‘IO’ action tha returns a value of type ‘()’.

‘main’ only produces side effects, that is why its type is

'''
main :: IO ()
'''

The ‘()’ denotes an empty tuple, which we refer to as unit. Unit is a value and also a type that has only this one inhabitant, which essentially represents nothing.

===== Read =====

While ‘Show’ takes things and turn them into human-readable strings, ‘Read’ takes strings and make them into things.

'''
λ> read "1984" :: Integer
1984
λ> read "xyz" :: Integer
*** Exception: Prelude.read: no parse
'''

A FUCKING RUNTIME ERROR! ‘read’ is a partial function. It doesn't return a proper value as a result for all possible inputs.


==== Instances are dispatched by type ====

Type classes are dispatched by type.

Type classes are defined by the set of operations and values that all instances must provide. Type class instances are unique pairings of a type class and a type. They define the ways to implement the type class methods for that type

* A type class defines a set of functions and/or values.
* Types have instances of that type class.
* The instances specify the ways that type uses the functions of the type class.

‘Num’ does not imply ‘Ord’, but ‘Int’ does. ‘:info’ is your friend.

A concrete type always implies the type classes that are provided for it.


--------------------
@TODO @QUESTION

===== Question about Eq and Ord =====

'''
data Rocks =
  Rocks String
  deriving (Eq, Show)

data Yeah =
  Yeah Bool
  deriving (Eq, Ord, Show)

data Papu =
  Papu Rocks Yeah
  deriving (Eq, Ord, Show)


-- eq :: Papu -> Papu -> Bool
-- eq p p' = (==) p p'

cmp :: Papu -> Papu -> Bool
cmp p p' = (>) p p'

'''

Why doesn't it work just by deriving ‘Ord’ if I want the function ‘cmp’ to use ‘>’? Why do I have to derive both ‘Eq’ and ‘Ord’?


--------------------
@TODO @QUESTION

Why doesn't this work?

'''
art :: Num b => (a -> b) -> Integer -> a -> Integer
art aToB i a = (+) i (aToB a) :: Integer
'''

Shouldn't ‘(+) i (aToB a)’ produce an Integer, since i is Integer?

--------------------









===== The End =====

Really! the end!

