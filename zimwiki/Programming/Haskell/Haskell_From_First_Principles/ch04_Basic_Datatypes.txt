Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-01-24T16:31:35-03:00

====== ch04 Basic Datatypes ======
Created Friday 24 January 2020

Types are also called data types.

Types, type constructors, data constructors, type signatures, type classes.

===== Anatomy of a data declaration =====

DATA DECLARATIONS are how DATATYPES are defined.

Type signatures live in the type level of our code. Values and expressions live at the term level.

When you are reading or writing type signatures, the type names or type constructors are what you use.

Data constructors are the values that inhabit the type they are defined in. They are the values that show up in your code, at the term level instead of the type level. By term level, we mean they are the values as they appear in your code or the values that your code evaluates to.

'''
data Bool = False | True
'''



If ‘:info <SomeType>’ shows ‘Unbounded’, it means that we can do ‘minBound :: ThatType’ and ‘maxBound :: ThatType’ to figure out their min and max bounds.


'''
λ> import GHC.Int
λ> :info Int8
...
instance Bounded Int -- Defined in ‘GHC.Enum’
...
λ> minBound :: Int8
-128
λ> maxBound :: Int8
127
'''

The upper bounds of ‘Word’ types is approximately double that of the same size ‘Int’ types because the bit in ‘Int’ values is used to express negative numbers is now used to signify extra positive numbers.

Five common Fractional types used in Haskell are Float, Double, Rational, Fixed, and Scientific.

Try :info and see.

===== Comparing Values =====
Page 100: “We know that alphabetical characters can be ordered, although we do not normally think of ‘a’ as being “less than” ‘b.’ But we can understand that here it means ‘a’ comes before ‘b’ in alphabetical order.”

Yes, but in ASCII and UTF-8, a has a numerical value that is less than b.

'a' is 97 in decimal, and 'A' is 65. So '''a' < 'A' == True''.

You can only compare lists of items where the items themselves also have an instance of Ord.

===== Go on and Bool me =====
We use type constructors in type signatures, and data constructors at the term-level code.

The type constructor Bool takes no arguments, but some other type constructors do take arguments.

Sum type, boolean disjunction, OR.
Product type, boolean conjunction, AND.
:info || &&

==== Question about data constructors vs char ====
@TODO @QUESTION
If False is one of Bool's data constructor, what is one data constructor for a character? 'z'? Why can we define something that is capitalized, like Blah and Woot and they are _values_, real data? Looks like data constructors sometimes are themselves data.

gzmorell@haskell-beginners:

All type and data constructors must start with uppercase letter, so 'z', z, or 1 are not valid data constructors. This obviously do not explain how Int or Char are defined inside Haskell. You can see how "magic" is done here https://tech.fpcomplete.com/haskell/tutorial/primitive-haskell

NOTE: That link talks about things I do not yet understand. Read it after I finish the book.

You can define your chars as "data MyChars = La | Lb | Ua | Ub" and then instance show and read to convert to/from String.


==== Conditionals with if-then-else ====
Haskell doesn’t have ‘if’ statements, but it does have if expressions. It’s a built-in bit of syntax that works with the Bool datatype.

'''
λ> if 2 > 1 then "Amazing!" else "Meh..."
"Amazing!"
λ> if 2 > 3 then "Amazing!" else "Meh..."
"Meh..."
'''

The type of the whole expressions above is String, because it is the type of value returned as the result. The types of the expressions in the if and then clauses must be the same.

Unlike in other languages, we can't do ''if someNum ...'' or ''if "" ...'' and expect that if it is a non-zero, or a non-empty string, then it is considered true. Nope, in haskell, there are not automatic type conversions like that (not to be confused with polymorphic types). When something expects a Bool, you'd better give it a Bool. :D

===== Tuples =====
Tuples have a distinctive, built-in syntax that is used at both type and term levels. Tuple arity, two-tuple (or pair), three-tuple, etc.

The two-tuple is expressed at both the type level and term level with the constructor ''(,)''.

Compare:

λ> :info Bool
data Bool = False | True

λ> :info (,)
data (,) a b = (,) a b

Both use `data'. Bool takes no params, while `(,)' takes two, `a' and `b'.

Bool is a sum type (one or the other). (,) is a product type, which needs both values to construct the tuple value.

λ> mytup = (3.14, "Yoda")
λ> mytuple
(3.14,"Yoda")
λ> fst mytup
3.14
λ> snd mytup
"Yoda"

λ> :info fst snd
fst :: (a, b) -> a
snd :: (a, b) -> 


λ> game = (1996 :: Int, "Tomb Raider")
λ> import Data.Tuple
λ> swap game
("Tomb Raider",1996)

fst' :: (,) a b -> a
fst' (a, b) = a

snd' :: (,) a b -> b
snd' (a, b) = b

λ> fst' ("Tomb", "Raider")
"Tomb"
λ> snd' ("Tomb", "Raider")
"Raider

The type can be either ''f :: (a, b) -> a'' or ''f :: (,) a b -> a''.

In the definition ''fst' (a, b) = ...'', the (a, b) part is pattern matching.

==== Q type mismatch ====
What is the problem?

tupFn :: (Int, [a]) -> (Int, [a]) -> (Int, [a])
tupFn (a, b) (c, d) = ((a + b), (b ++ d))

a in the first tuple param is Int. There is no ++ for Int. We can't do b ++ d for the last element of the returned tuple. We wanted `c ++ d', not `b ++ d'.

===== Lists =====
Tuples use (,) both for type constructor in type signatures and to express values at the term level. Lists, similarly, use [] both for type constructor in type signatures and for expressing lists of values at the term level.

Lists, contrary to tuples, require that all elements have the same type. All strings, all ints, all whatever.


The number of values that will be in the list isn’t specified in the type – unlike tuples where the arity is set in the type and immutable.

This is invalid for a list:

game = ["Tomb Raider", 1996 :: Int, True]

But those values are OK for a three-tuple:

λ> game = ("Tomb Raider", 1996 :: Int, True)
λ> :type list
list :: ([Char], Int, Bool)

This is OK:

λ> game = ["Tomb", "Raider", "Anniversary"]
λ> :type game
game :: Char

game is a list of list of Char.

String is a type alias for [Char].

If a function can work on a list of [a], it can work on a list of [Char], [Int], [Integer], [Double], etc. because these are more specific than [a].

==== Foldable t => t a and Foldable t => t [a] ====
@TODO
**NOTE**: `Foldable t => t a' is `[a]', which id different than `Foldable t => t [a]', which is `a'.

λ> :type length
length :: Foldable t => t a -> Int

λ> :type concat
concat :: Foldable t => t [a] -> [a]

λ> :type (++)
(++) :: [a] -> [a] -> [a]

===== Upper and Lower case =====
Trying to start a variable name, or function name with uppercase letter causes errors because GHCi thinks we are trying to use a data constructor that is not in scope.


λ> \X -> x
<interactive>:183:2: error: Not in scope: data constructor ‘X’

F xs = (+) w 1
  where w = length xs
Not in scope: data constructor ‘F’

===== The End =====


[DATETIME: Sun, 2020-01-26 10:58]


