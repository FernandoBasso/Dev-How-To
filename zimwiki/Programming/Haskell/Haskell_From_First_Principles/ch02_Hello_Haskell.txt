Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-01-23T11:31:41-03:00

====== ch02 Hello Haskell ======
Created Thursday 23 January 2020

===== Interacting with Haskell code =====

'''
λ> (^) 10 2
100
λ> (^) 2 10
1024
'''

Why two different results?

Because the ‘^’ function is not [[https://en.wikipedia.org/wiki/Commutative_property|commutative]].

'''
(^) 10 2 == (*) 10 10
(^) 2 10 == 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2
'''

--------------------
How to read ‘::’ from type signatures aloud?

You say either “has the type” or “has type”.

Read more [[https://wiki.haskell.org/Keywords#::|here]].

--------------------

===== GHCi basics =====

'''
:load program.hs
:module
:type (some function)
:info (some function or type or whatever)
:reload
:quit
'''

‘:module’ unloads any loaded file and goes back to the default, standard Prelude module.

--------------------

===== Understanding expressions =====

Everything in Haskell is either an expression or a declaration. Declarations are toplevel bindings that allow naming expressions.

Examples of expressions:

'''
1
(+) 2 3
foldr (+) 0 [1..5]
take 3 [1..]
"Tomb Raider" ++ " " ++ "The Angel of Darkness"
'''

Programs are large expressions composed of smaller expressions.

The expression ‘1’ has no further possible reduction steps, so, it stands for itself and results in the value 1. The other expressions are reduced until no further reduction is possible at which point the final, irreducible value is produced. An irreducible expression is generally referred to as a value.

When an expression can NOT be further evaluated/reduced it is said to be in **NORMAL FORM** (or CANONICAL FORM). When expressions can still be further reduced they are called **REDEXES**.

‘1 + 1’ is a redex, not in normal form, but ‘2’ is in normal form.

We usually mean “value” to be an irreducible expression, and an expression when we have reducible expression, although technically, values are (irreducible) expressions, but expressions nonetheless.


--------------------

===== Functions =====

Expressions are the most basic units of a Haskell program, and a function is a specific type of expression.

Functions in Haskell take one argument and and return one result. When it looks like it can take more than one argument, that is syntax sugar. In Haskell, when it seems like we are passing multiple arguments to a function, we are actually applying a series of nested functions, each to one argument. This is called **CURRYING**.

Functions can also appear in the expressions that form the bodies of other functions or be used as arguments to functions, just as any other value can be.

**FORMAL PARAMETER** is the variable name used when defining a function.

**ARGUMENT** is the actual value which stands for the formal parameter when applying a function.

In the function definition ‘add1 n = n + 1’, the ‘n’ before the ‘=’ definition operator is a formal parameter, but wen we apply ‘add1 5’, then ‘5’ is the argument that stands for the formal parameter ‘n’.

Function //definition// a.k.a function //declaration.//

Functions start with lowercase, and then camelCase may be used where appropriate, like in ‘sayHello’ or ‘parseTitle’.

--------------------

===== Evaluation =====

Evaluating an expression is reducing the terms to their simplest form (normal form), when it reaches an irreducible state, also a.k.a value.

Haskell uses non-strict (a.k.a “lazy”) evaluation strategy that defers evaluation of terms until the last possible moment.

Values are irreducible, but applications of functions to arguments are reducible. Reducing an expression means evaluating the terms until you’re left with a value. As in the lambda calculus, application is evaluation: applying a function to an argument allows evaluation or reduction. Values are expressions, but they cannot be reduced further. Values, in other words, are a terminal point of reduction.

NORMAL FORM is also called CANONICAL FORM.

Haskell doesn’t evaluate everything to canonical or normal form
by default. Instead, it only evaluates to **weak head normal form**
(**WHNF**) by default. What this means is that not everything will get
reduced to its irreducible form immediately.

--------------------
Infinite examples on the web, the book, and every other universe use ‘f’ as the name of functions or to name parameters that are functions. Therefore, the expression ‘(\f -> (1, 2 + f)) 2’ from the book may trick one into thinking that ‘f’ is a function. It is NOT. It is just a variable. It could have been named ‘n’ or ‘x’, like ‘(\n -> (1, 2 + n)) 2’.

'''
λ> (\n -> (1, 2 + n)) 2
(1,4)
'''

The expression is a lambda expression that takes a parameter and then produces the final value, a tuple. ‘2 + 2’ is not evaluated to 4 until the last possible moment.

'''
λ> v = (\f -> (1, 1 + f)) 1
λ> :sprint v
v = _
'''

The “_” means that v has not been fully evaluated. Since we assigned the expression to a variable, it has not yet produced the final result. It has not yet be reduced to Normal Form.

@TODO

'''
λ> v = (\f -> (1, 1 + f)) 1
λ> print v
(1,2)
λ> :sprint v
v = _
'''

Why does ‘:sprint’ shows ‘v = _’, meaning it has not yet been evaluated when I clearly printed and caused ‘v’ to be, in fact, evaluated?

According to glguy#haskell-beginners, it has to do with the “often-maligned Monomorphism Restriction,” and “That gets reevaluated at every use because it's a function of your choice of types.”

'''
λ> :set -XMonomorphismRestriction 
λ> v = (\f -> (1, 1 + f)) 1
λ> v
(1,2)
λ> :sprint v
v = (1,2)
'''

Now, look at this:

'''
λ> :set -XNoMonomorphismRestriction 
λ> v = (\f -> (1, 1 + f)) 1
λ> v
(1,2)
λ> :sprint v
v = _
'''

https://stackoverflow.com/questions/32496864/what-is-the-monomorphism-restriction

--------------------

==== Exercises: Comprehension Check ====
Page 35.

=== 01 playing with exprs ===

'''
λ> half x = (/) x 2
λ> square x = (*) x x

λ> square (half 3)
2.25
'''


=== 02 writing a function ===

'''
λ> f n = 3.14 * (n * n)
λ> f 5
78.5
λ> f 10
314.0
λ> f 2
12.56
λ> f 4
50.24
'''

3.14 does not change. That value is hard-coded inside the function body. The value that is multiplied inside parentheses do change, so, we make it a parameter.

=== 03 function using `pi' ===

'''
λ> f n = pi * (n * n)
λ> f 2
12.566370614359172
λ> f 4
50.26548245743669
'''

--------------------

===== Infix operators =====

Functions (that are not special symbols like ‘+’, ‘<’ or ‘$’) are PREFIX BY DEFAULT.

Operators are functions that can be used in infix style. All operators are functions; not all functions are operators.

Make prefix function infix by enclosing them in backticks, like ‘10 `div` 3’, and make infix functions prefix by enclosing them inside in parenthesis, like in ‘(+) 2 3)’.

If the function name is alphanumeric, it is a prefix function by default, and not all prefix functions can be made infix. If the name is a symbol, it is infix by default but can be made prefix by wrapping it in parentheses.

==== Associativity and precedence ====

The ‘:info’ command shows precedence and associativity of operators and functions:

'''
λ> :info div
class (Real a, Enum a) => Integral a where
  ...
  div :: a -> a -> a
  ...
  	-- Defined in ‘GHC.Real’
infixl 7 `div`

λ> :info +
class Num a where
  (+) :: a -> a -> a
  ...
  	-- Defined in ‘GHC.Num’
infixl 6 +

λ> :info ^
(^) :: (Num a, Integral b) => a -> b -> a 	-- Defined in ‘GHC.Real’
infixr 8 ^
'''

Note the “infixl” (left) and “infixr” (right) words followed by a number indicating their precedence.

Precedence is on a scale of 0-9.

For ‘+’ and ‘*’, being infixl doesn't change the result because they are associative, but things are different with ‘^’, for example.

'''
λ> (2 + 3) + 4
9
λ> 2 + (3 + 4)
9

λ> 2 ^ 3
8
λ> 3 ^ 2
9

λ> 2 ^ 3 ^ 4
2417851639229258349412352
λ> (2 ^ 3) ^ 4
4096
'''

Because ‘^’ associates to the right, infixr, ‘2 ^ 3 ^ 4’ is the same as ‘2 ^ (3 ^ 4)’.

Addition and multiplication are associative, so, shifting the parenthesis around doesn't change the result.

Division and exponentiation are NOT associative, so, shifting the parenthesis around DOES CHANGE THE RESULT.



==== Exercises: Parentheses and Association ====
Page 39.

=== 01 add, multiply ===
a) ‘8 + 7 * 9’
b) ‘(8 + 7) * 9’

a and b produce different results. Parentheses here do make a difference. In a, first ‘7 * 9’ is reduced first, then its result is added to 8. In b, because of the parenthesis, first add 8 and 7, and then multiply that result by 9.

=== 02 perimeter, multiply and add ===
a) ‘perimeter x y = (x * 2) + (y * 2)’
b) ‘perimeter x y = x * 2 + y * 2’

No change. Parenthesizing multiplication around an addition does not change anything. Both multiplication expressions would have been performed first anyway.

=== 03 divide and add ===
a) ‘f x = x / 2 + 9’
b) ‘f x = x / (2 + 9)’

Here, use of parenthesis to cause the expression ‘2 + 9’ to be reduced before the division does change the result.

===== Declaring values =====

The order of declaration in a source file doesn't matter because GHCi has this feature called “two-pass evaluation” and it knows all the values that have been defined. In the REPL, order does matter.

'''
-- file: dev.hs
x = 10 * 5 + y
result = x * 5
y = 10
'''

Even though ‘y’ is used //before// it is declared, it works in a source file.


==== Exercises: Heal the Sick ====
Page 46.

=== 01 area space after dot ===

'''
area x = 3. 14 * (x * x)
'''

There is a space after the dot in ‘3. 14’. Fixed:

'''
area x = 3.14 * (x * x)
'''


=== 02 unbound variable, unused variable ===

'''
double x = b * 2
'''

The function binds ‘x’ formal parameter but attempts to use ‘b’ the the function body, which is not in scope. Fix: use ‘x’ inside the body of the function or bind ‘b’ instead of ‘x’ in the head.

'''
double x = x * 2
double' b = b * 2
'''


==== 03 indentation mishap ====

'''
x = 7
 y = 10
f = x + y
'''

There is a horrible, monstrous whitespace before ‘y’ causing GHCi to throw a fit.

'''
x = 7
y = 10
f = x + y
'''


https://www.quora.com/How-do-I-use-the-dollar-sign-separator-in-Haskell

https://stackoverflow.com/questions/940382/what-is-the-difference-between-dot-and-dollar-sign


===== Arithmetic functions =====

“integral” division refers to division of integers. Because it’s integral and not fractional, it takes integers as arguments and returns integers as results. That’s why the results are rounded.

‘div’ rounds down. ‘quot’ rounds toward zero.

'''
λ> (/) 10 3
3.3333333333333335
λ> div 10 3
3
λ> (/) 10 (-3)
-3.3333333333333335
λ> div 10 (-3)
-4

λ> (/) 11 4
2.75
λ> quot 11 4
2
'''


==== Quotients and Remainders ====

[[https://stackoverflow.com/questions/8111120/integral-operators-quot-vs-div|Integral operators quot vs. div (]][[https://stackoverflow.com/questions/8111120/integral-operators-quot-vs-div|s]][[https://stackoverflow.com/questions/8111120/integral-operators-quot-vs-div|tackoverflow)]]

‘quot’ and ‘rem’ vs ‘div’ and ‘mod’.

‘mod’ has to do with [[https://en.wikipedia.org/wiki/Modular_arithmetic|modular arithmetic]]. It produces the remainder of a modular division.

The result of ‘mod’ has the same sign as the divisor, while the result of ‘rem’ has the same sign as the dividend.

===== Parenthesization =====

'''
λ> :info ($)
($) :: (a -> b) -> a -> b
infixr 0 $
'''

Uses of ‘$’:

'''
λ> (2^) 2 + 2
6
λ> (2^) (2 + 2)
16
λ> (2^) $ 2 + 2
16
'''

The ‘$’ function evaluates everything to its right first and can
thereby be used to delay function application.

'''
(2 ^) $ 2 + 2 $ (* 1)
'''

Because ‘$’ is infixr, we must evaluate ‘2 + 2 $ (* 1)’ first. ‘+’ has higher precedence than ‘$’, so, ‘2 + 2’ must be evaluated first. 4 is not a function and therefore cannot by applied to ‘(* 1)’. Remember ‘$’ takes ‘f $ x’ and makes it ‘f x’, so, we would be doing ‘4 (* 1)’. 4 is not a function, and we cannot apply 4 to ‘(* 1)’.

==== Parenthesizing infix operators ====

Sectioning commutative functions such as ‘+’ or ‘*’ to the right or to the left doesn't change the result:

'''
λ> (+ 3) 2
5
λ> (3 +) 2

λ> (^ 3) 2
8
λ> (3 ^) 2

λ> (/ 1) 2
2.0
λ> (1 /) 2
0.5
'''


==== Subtraction ====

‘(- 1) 1’ don't work, because in certain situations, like, in front of a single operand (not after, not in the middle of two operands), the ‘-’ symbol represents “negation”, not subtraction. Use ‘subtract’ instead.

'''
λ> (subtract 1) 2
-1
λ> (1 `subtract`) 2
1
'''

NOTE: ‘subtract’ is a prefix function. No need for backticks in the first case. In the second case, we could just go with ‘-’ instead of ‘`subtract`’.

‘x = -1’ works, though. But,

'''
λ> f = (- 1)
λ> f 2
...ERROR...
'''


===== Let and Where =====

‘let’ introduces an expression, and can be used anywhere an expression can appear. ‘where’ is a declaration.



===== Exercises: A head code =====
Page 59.

==== let expressions ====

=== 01 let ===

‘let x = 5 in x’ produces 5. The ‘in x’ is like a return statement in this case. We bind 5 to ‘x’ and “return” ‘x’.

Do not let the ‘=’ operator make you think that “5 in x” is one entire thing. No... ‘let x = 5’ is one part of the whole thing, and then ‘in 5’ is the other part of it. If we wrote it like a below (in a source file), it would be clearer the different “parts”:

'''
let1 = let x = 5
       in x
'''


=== 02 let ===

'''
let x = 5 in x * x
'''

Similar to the previous one. Produce ‘x * x’, which is 25. Could be rewritten as (in a source file)let x = 5; y = 6 in x * y:

'''
let2 = let x = 5
       in x * x
'''


=== 03 let ===

'''
let x = 5; y = 6 in x * y
'''

Produces 30. We use ‘let’ to bind two values for ‘x’ and ‘y’, and both are in scope for the ‘in’ clause. In a source file, could be rewritten as:

'''
let3 = let x = 5
           y = 6
       in x * y
'''


=== 04 let ===

'''
let x = 3; y = 1000 in x + 3
'''

Similar to the previous one. Just that the ‘in’ clause ignores ‘y’, not using it for anything, and the result is 6. In a source file:

'''
let4 = let x = 3
           y = 1000
       in x + 3
'''


==== Rewrite to where ====
Page 60.

=== 01 where ===

'''
let x = 3; y = 1000 in x * 3 + y
'''

Solution:

'''
where1 = result
  where
    x      = 3
    y      = 1000
    result = x * 3 + y
'''


=== 02 where ===

'''
let y = 10; x = 10 * 5 + y in x * 5
'''

Solution:

'''
where2 = result
  where
    y      = 10
    x      = 10 * 5 + y
    result = x * 5
'''


=== 03 where ===

'''
let x = 7
    y = negate x
    z = y * 10
in z / x + y
'''

Solution:

'''
where3 = result
  where
    x      = 7
    y      = negate x
    z      = y * 10
    result = z / x + y
'''


===== Chapter Exercises =====
Page 60.

==== Parenthesization ====
Page 61.

=== 01 ===

'''
λ> 2 + 2 * 3 - 1
7
λ> 2 + (2 * 3) - 1
7
λ> (2 + (2 * 3)) - 1
7
'''


=== 02 ===

'''
λ> (^) 10 $ 1 + 1
100
λ> ((^) 10) $ (1 + 1)
100
'''


=== 04 ===

'''
λ> 2 ^ 2 * 4 ^ 5 + 1
4097
λ> (2 ^ 2) * (4 ^ 5) + 1
4097
λ> ((2 ^ 2) * (4 ^ 5)) + 1
4097
'''


==== Equivalent expressions ====
Page 62.

=== 01 ===

'''
1 + 1
2
'''

Both produce the same result, 2.

=== 02 ===

'''
10 ^ 2
10 + 9 * 10
'''

‘10 ^ 2’ produces 100. In the second expression, ‘9 * 10’ is reduced first, producing 90, which is added to 10, producing 100. Therefore, both expressions produce the same result, 100.

=== 03 ===

'''
400 - 37
(-) 37 400
'''

‘400 - 37’ is “subtract 37 from 400.” However, ‘(-) 37 400’ is “subract 400 from 37.” So, the expressions produce different results.

'''
λ> 400 - 37
363
λ> (-) 37 400
-363
'''

Compare:

'''
400 - 37 == (-) 400 37
37 - 400 == (-) 37 400
'''


=== 04 ===

'''
100 `div` 3
100 / 3
'''

Different results because ‘div’ does integral division, whereas ‘/’ does fractional division.

'''
λ> 100 `div` 3
33
λ> 100 / 3
33.333333333333336
'''


=== 05 ===

'''
2 * 5 + 18
2 * (5 + 18)
'''

Different results because of the order of evaluation.

==== More fun with functions ====

Code properly reordered to be run either from the file or from the REPL:

'''
z = 7
y = z + 8
x = y ^ 2
waxOn = x + 5
'''


=== 01 ... 07 ===

'''
{-# LANGUAGE NoMonomorphismRestriction #-}

z = 7
y = z + 8
x = y ^ 2
waxOn' = x + 5

-- Using ‘where’.
waxOn = x + 5
  where
    z = 7
    y = z + 8
    x = y ^ 2

-- Using ‘let’.
waxOn'' = let z = 7
              y = z + 8
              x = y ^ 2
          in x + 5

triple n = n * 3


waxOff x = triple x

waxOff' x = triple x / 10
'''

REPL session:

'''
λ> waxOff 1
3
λ> waxOff waxOn
690
λ> waxOff (- 50)
-150

λ> waxOff' waxOn
69.0
λ> waxOff' 1
0.3
λ> waxOff' waxOn
69.0
λ> waxOff' (-50)
-15.0
'''




===== The End =====

