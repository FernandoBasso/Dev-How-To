Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-02-20T17:19:22-03:00

====== Evaluation Examples ======
Created Thursday 20 February 2020

===== foldr (+) =====

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     = z
foldr f z (x:xs) = f x (foldr f z xs)

f = (+)

foldr f 0 [1, 2, 3]

f 1 (foldr f 0 [2, 3])
f 1 (f 2 (foldr f 0 [3]))
f 1 (f 2 (f 3 (foldr f 0 [])))
f 1 (f 2 (f 3 0))
f 1 (f 2 3)
f 1 5
6

===== foldl (+) v1 =====

foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f z []     = z
foldl f z (x:xs) = foldl f (f z x) xs

f = (+)

foldl f 0 [1, 2, 3]
z is 0

foldl f (f 0 1) [2, 3]
z is 1

foldl f (f 1 2) [3]
z is 3

foldl f (f 3 3) []
z is 6

6


‘foldl’ does not recursively ask for more fold with ‘xs’. It just calls itself again with the new value of ‘z’, so, it doesn't seem to have a way to nest ‘foldl’ invocations it happens with ‘foldr’.

But we could nest ‘f’ calls.

λ> foldl f 0 [1, 2, 3]
6

λ> foldl f (f 0 (f 0 1)) [2, 3]
6

λ> foldl f (f 0 (f 0 (f 0 2))) [3]
5

λ> foldl f (f 0 (f 0 (f 1 2))) [3]
6

λ> foldl f (f 0 (f 0 (f 1 (f 2 3)))) []
6


===== foldl (flip (*)) =====

foldl :: (acc -> x -> acc) -> acc -> [x] -> acc
foldl f z []     = z
foldl f z (x:xs) = foldl f (f z x) xs

f = (*)

foldl (flip f) ((flip f) 1 1) [2, 3]
acc = 1, (1 * 1)

foldl (flip f) ((flip f) 1 2) [3]
acc = 2, (1 * 2)

foldl (flip f) (flip f) 2 3) []
acc = 6, (2 * 3)

Reaches base case, returns z, our ‘acc’.




===== foldl composition with ++ and show =====

foldl :: (acc -> x -> acc) -> acc -> [x] -> acc
foldl f z []     = z
foldl f z (x:xs) = foldl f (f z x) xs

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     = z
foldr f z (x:xs) = f x (foldr f z xs)

λ> :t foldl
foldl :: (acc -> x -> acc) -> acc -> [x] -> acc

λ> :t ((++) . show)
((++) . show) :: Show a => a -> [Char] -> [Char]

foldl ((++) . show) "" [1, 2, 3]

foldl ((++) . show) (((++) . show) "" 1) [2, 3]

"" 1

‘foldr’ applies ‘f x’. So, we apply ‘((++) . show)’ to ‘1’ first, not to ‘""’ first.

‘foldl’ applies ‘f’ to the zero/acc first, and the current ‘x’ (1, 2, 3) do not get converted to string, and are attempted to be concatenated to the ‘acc’ as a number, which is incorrect and causes errors.


λ> ((++) . show) "" 1
...error...

λ> ((++) . show) 1 ""
"1"


===== foldr const 'a' [1,2, 3] =====

foldr const 'a' [1, 2, 3]

λ> const 1 'a'
1

λ> const 'a' 1
'a'

The probolem with fold is the types.

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     = z
foldr f z (x:xs) = f x (foldr f z xs)


Zero has the type ‘Char’, and the list is of type ‘Num’. The type of zero and the elements of the list must be the same.

λ> foldr const 'a' "bcd"
'b'

λ> foldr const 'a' ['b', 'c', 'd']
'b'

λ> foldr const 0 [1, 2, 3]
1

We can also ‘flip const’ so it flips the args:

λ> :t const
const :: a -> b -> a

λ> :t (flip const)
(flip const) :: b -> c -> c

λ> foldr (flip const) 'a' [1, 2, 3]
'a'

Or use ‘foldl’ instead of ‘foldr’:

λ> foldl const 'a' [1, 2, 3]
'a'



