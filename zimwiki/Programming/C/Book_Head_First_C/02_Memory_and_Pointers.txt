Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-05-28T07:23:30-03:00

====== 02 Memory and Pointers ======
Created Thursday 28 May 2020

A pointer is an address of a piece of data in memory.

Instead of passing full data copies around, you pass addresses of where data is stored. They are a form of indirection.

Pointers main goals:
* avoid (expensive, time consuming) copies
* share data

C sends arguments as values (unless the argument is an array/pointer, which). To pass the variable itself, use the “address of” operator, ''&''.

Print the address of a variable in hex:

'''
printf ("Address of “latitude” is: %p\n",
       (void *) &latitude);
// → Address of “latitude” is: 0x7fffe29ddf84
'''

Note the “&” in front of the variable.

* [[https://stackoverflow.com/questions/7290923/when-printf-is-an-address-of-a-variable-why-use-void|When printf is an address of a variable, why use void*?]]
* [[https://stackoverflow.com/questions/24867814/printfp-and-casting-to-void|printf(“%p”) and casting to (void *)]]

In short, ''%p'' format specifier requires a pointer to void.

'''
int x = 1;
int *x_ptr = &x;
int x_val = *x;
'''

When “*identifier” is on the left-hand side, it means we are creating a pointer.

When “*identifier” is on the righ-hand side, it means we are accessing the value inside “identifier” (dereferencing).

After we do ''int *x_ptr = &x'', from that point on, ''x_ptr'' stores the memory of ''x''. That is, ''x_ptr'' (without “*”) is the memory location if ''x''. This comparison produces true/1:

'''
x_ptr == &x
'''

The ''*'' and ''&'' operators are opposites. The ''&'' operator takes a piece of data and tells you where it’s stored. The ''*'' operator takes an address and tells you what’s stored there. Because pointers are sometimes called references, the ''*'' operator is said to dereference a pointer.

To change the contents of ''x'' through its pointer, we need to use ''*'' again, but this time on the  left-side:

'''
*x_ptr = 2;
'''

An array variable is the pointer to the first element of the array.

'''
char str[] = "Yoda";
printf ("%d\n", str == &str[0]);
// 1 (true)
'''

When we pass an array to a function, we are actually passing a pointer (to the array's first element).

'''
void fn (char msg[])
{
  printf ("%lu\n", sizeof (msg));
}
'''

The above produces “warning: ‘sizeof’ on array function parameter ‘msg’ will return size of ‘char *’ [-Wsizeof-array-argument]”

Looks like the compiler [[https://stackoverflow.com/a/13006722/2855955|thinks we are assuming]] ''sizeoff'' on a char array will give us the “length of the string”. We know it will just give us the number of bytes of the pointer to the first char. Yet, to remove the warning, we can replace ''char msg[]'' with ''char *msg'' in the function signature:

'''
void fn (char *msg)
{
  printf ("%lu\n", sizeof (msg));
}
'''

And remember that ''sizeof'' results in an “unsigned long int” which require one of ''%ld'', ''%lu'', or ''%lx''.

'''
char s[] = "Jedi";
char *p = s;

printf ("%lu\n", sizeof (s));
// → 5
// “Jedi” plus the nul terminator \0.

printf ("%lu\n", sizeof (p));
// → 8
// The size of a pointer storage on my 64-bit machine.
'''


“sizeof an array” produces the size of an array. But when the array is treated as a pointer (like when it is passed as argument to a function), then sizeof produces the size, in bytes, necessary to hold a pointer.

A function saying ''(char msg[])'' only //lookes like// it is receving an array, but it will allways actually receive a pointer (to the first element of the array).

**ARRAYS ARE CONSTANT POINTERS**

““
When you create a pointer variable, the machine will allocate 4 or 8 bytes of space to store it. But what if you create an array? The computer will allocate space to store the array, but it won’t allocate any memory to store the array variable. The compiler simply plugs in the address of the start of the array. But because array variables don’t have allocated storage, it means you can’t point them at anything else.
””

That means we can reassign, increment or decrement a pointer, but not an array variable. Array variables are constant pointers.

'''
ptr++ // OK
arr++ // ERROR
'''

If you assign an array to a pointer, you do not acutally assign the array to the pointer. Rather, you assign the address of the first element of the array to the pointer.

When you pass an array to a function, you do not actually pass the array to the function. Rather, you pass the address of the first element of the array, which means it is a pointer.

A function or a pointer cannot possibly know the length of the “original array”. For functions, a parameter with the length is necessary, or some other means of identifying the end of the data, like the presence of ''\n'' for strings.

Retrieve the first element:
'''
arr[0]
*arr
*(arr + 0)
'''

Retrieve the Nth element:
'''
arr[n]
*(arr + n)
'''

Because of pointer arithmetic, “the index is just the number that’s added to the pointer to find the location of the element.”

NOTE: For the ''%s'' specifier and pointers, we don't use ''*'' on the pointer. We do not pass a string to ''%s''. We pass it an address of an array of chars (and hope it contains a NUL terminator ''\0'').

'''
%s
'''
 takes a ''char *'', not a literal value.

WRONG:
'''
char msg[] = "Don't call me";
printf ("%s\n", *(msg + 6));
'''

CORRECT:
'''
char msg[] = "Don't call me";
printf ("%s\n", (msg + 6));
'''

Pointers have types so the compiler knows how much to add or subtract when doing pointer arithmetic.

A char is 1 byte, so ''my_char_ptr + 1'' moves the pointer 1 memory address forward. An int type of 4 bytes causes ''my_int_ptr + 1'' to move 4 memory addresses forward.

a[b] is exactly equivalent to *(a + b)
Which is equivalent to *(b + a)
Which is equivalent to b[a]

“it's the other languages that has brainwashed you into thinking a[0] is special”

@QUESTION
Why doesn't ''printf ("%s\n", 6[msg])'' work?

Perhaps because ''%s'' takes a ''char *'' and ''6[msg]'' returns an int?

'''
char name[18];
short age;

scanf ("%17s", name);
scanf ("%hd", &age);
'''

Note how ''scanf'' takes “name” and “&age”, the latter with the //address of// operator. That is because arrays are already pointers to a memory locaion so we don't need the ''&'' operator.

ALWAYS limit the length of strings being read with ''scanf''. Never do a plain ''scanf ("%s", arr)''. SECURITY ALERT! Always place a limit, like above, if the array has space for 18 bytes, use ''scanf ("%17s", name)'' so we can store up to 17 chars plus the NUL terminator '\0'.

Prefer ''fgets'' which **requires** a limit param. Unless... you have to read multiple inputs. ''fgets'' reads into one pinter at a time. ''scanf'' (and its friends) can read onto multiple pointers at a time.

String literals can't be updated. Can't do:
'''
char *s = "hey";
s[0] = 'H'; // Segmentation fault.
'''

But can create an array instead so we can update it later:
'''
char s[] = "hey";
s[0] = 'H'; // OK.
'''

String literals go into the “constants” area of the memory. This area is read only. Simple as that.

{{./constant-strings.png}}

In ''char *p = "hey";'', ''p'' is a pointer to a piece of read-only memory (because of the string constant literal).

In ''char a[] = "you";'', ''a'' is a completely new, fresh copy of the string literal. The string literal is still in the constants/read-only area of the memory, but its copy in ''a'' can now be freely modified and updated at will.

Also, doing ''char s[] = "hello"'' causes the compiler to set aside enough memory in the array ''s'' to store the string with its NUL terminator. Since we are providing the string right then and there, the compiler counts the chars and figures out the amount of RAM needed for ''s''.

And just to make it clear: ''char name[] = "Yoda";'' allocates space in RAM and also **copies the contents** of the string literal into the stack memory.

To avoid the gotcha, use ''const char *arr'' to declare your literal, so the compiler can catch attempts to modify the string and tell you and refuse to compile your program.

'''
const char *name = "yoda";
...
name[0] = 'Y';
// Compiler error and no executable generated.
'''

A declaration is a piece of code that declares that something (a variable, a function) exists. A definition is a piece of code that says what something is. If you declare a variable and set it to a value (e.g., int x = 4; ), then the code is both a declaration and a definition.

















