Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-05-28T07:23:30-03:00

====== 02 Memory and Pointers ======
Created Thursday 28 May 2020

A pointer is an address of a piece of data in memory.

Instead of passing full data copies around, you pass addresses of where data is stored. They are a form of indirection.

Pointers main goals:
* avoid (expensive, time consuming) copies
* share data

C sends arguments as values (unless the argument is an array/pointer, which). To pass the variable itself, use the “address of” operator, ''&''.

Print the address of a variable in hex:

'''
printf ("Address of “latitude” is: %p\n",
       (void *) &latitude);
// → Address of “latitude” is: 0x7fffe29ddf84
'''

Note the “&” in front of the variable.

* [[https://stackoverflow.com/questions/7290923/when-printf-is-an-address-of-a-variable-why-use-void|When printf is an address of a variable, why use void*?]]
* [[https://stackoverflow.com/questions/24867814/printfp-and-casting-to-void|printf(“%p”) and casting to (void *)]]

In short, ''%p'' format specifier requires a pointer to void.

'''
int x = 1;
int *x_ptr = &x;
int x_val = *x;
'''

When “*identifier” is on the left-hand side, it means we are creating a pointer.

When “*identifier” is on the righ-hand side, it means we are accessing the value inside “identifier” (dereferencing).

After we do ''int *x_ptr = &x'', from that point on, ''x_ptr'' stores the memory of ''x''. That is, ''x_ptr'' (without “*”) is the memory location if ''x''. This comparison produces true/1:

'''
x_ptr == &x
'''

The ''*'' and ''&'' operators are opposites. The ''&'' operator takes a piece of data and tells you where it’s stored. The ''*'' operator takes an address and tells you what’s stored there. Because pointers are sometimes called references, the ''*'' operator is said to dereference a pointer.

To change the contents of ''x'' through its pointer, we need to use ''*'' again, but this time on the  left-side:

'''
*x_ptr = 2;
'''

An array variable is the pointer to the first element of the array.

'''
char str[] = "Yoda";
printf ("%d\n", str == &str[0]);
// 1 (true)
'''

When we pass an array to a function, we are actually passing a pointer (to the array's first element).

'''
void fn (char msg[])
{
  printf ("%lu\n", sizeof (msg));
}
'''

The above produces “warning: ‘sizeof’ on array function parameter ‘msg’ will return size of ‘char *’ [-Wsizeof-array-argument]”

Looks like the compiler [[https://stackoverflow.com/a/13006722/2855955|thinks we are assuming]] ''sizeoff'' on a char array will give us the “length of the string”. We know it will just give us the number of bytes of the pointer to the first char. Yet, to remove the warning, we can replace ''char msg[]'' with ''char *msg'' in the function signature:

'''
void fn (char *msg)
{
  printf ("%lu\n", sizeof (msg));
}
'''

And remember that ''sizeof'' results in an “unsigned long int” which require one of ''%ld'', ''%lu'', or ''%lx''.









