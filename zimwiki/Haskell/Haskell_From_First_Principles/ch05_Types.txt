Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-01-27T08:16:04-03:00

====== ch05 Types ======
Created Monday 27 January 2020

==== Types ====
A data type declaration defines a type constructor and data constructors.

Data constructors are values of a particular type and are also functions that let us create values of a particular type.

In Haskell, you cannot create untyped data, so except for a sprinkling of syntactic sugar for things like numbers or functions, everything originates in a data constructor from some definition of a type.

===== What are types for? =====
Type systems in logic and mathematics have been designed to impose constraints that enforce correctness.

The ‘Bool’ type has two inhabitants, ‘True’ and ‘False’. When a type ‘Bool’ is declared in type signature, the compiler will only accept one of those two values, and when one of those two values appear in the code, the compiler knows they are from the ‘Bool’ type.

In Haskell, where //typing is static//, typechecking occurs //at compile time//.

Statically typed languages allow otimizations because the compiler can predict certain things based on the type.


===== How to read type signatures =====
Can query types for functions, partially-applied functions, and values.

‘:type 1’ displays typeclass information rather than information of a concrete type. The compiler doesn't know and doesn't need to infer a specific type until it is forced to do so.

λ> :type 1
1 :: Num p => p

Explicitly tell the compiler the type:

λ> n = 1 :: Double
λ> :type n
n :: Double

Typeclasses are not types.

λ> n = 1 :: Fractional
...error...

Must use concrete type of the ‘Fractional’ typeclass.

λ> n = 1 :: Float
λ> :type n
n :: Float

λ> :info Fractional
class Num a => Fractional a where
  (/) :: a -> a -> a
  recip :: a -> a
  fromRational :: Rational -> a
  {-# MINIMAL fromRational, (recip | (/)) #-}
		-- Defined in ‘GHC.Real’
__instance Fractional Float__ -- Defined in ‘GHC.Float’
__instance Fractional Double__ -- Defined in ‘GHC.Float’

So, both ‘Float’ and ‘Double’ have instances of the ‘Fractional’ typeclass.

==== Understanding the function type ====
[DATETIME: Mon, 2020-01-27 11:04]

The arrow ‘(->)’ is the type constructor for functions. It is a type constructorl like ‘Bool’, except ‘(->)’ takes arguments and has no data constructors.

**REMEMBER**: parens in type signatures just imply grouping, not precedence.

λ> :info Bool
data Bool = False | True

λ> :info (->)
data (->) (a :: TYPE q) (b :: TYPE r)
infixr 0 (->)

λ> :info (,)
data (,) a b = (,) a b

Note how a tuple type constructor takes params (‘a’ and ‘b’ before the ‘=’), but the function type constructor does not take any params (‘=’ doesn't even show up in the function type constructor). The value that shows up at term level is the function. Functions are values.

A function is a value/expression that it can be applied, and the structure of the type demonstrates this. The arrow is an infix operator that has two parameters and associates to the right (although function application is left associative)

==== Typeclass-constrained type variables ====
[DATETIME: Mon, 2020-01-27 11:16]

λ> :type (+)
(+) :: Num a => a -> a -> a

λ> :type (/)
(/) :: Fractional a => a -> a -> a

‘(+)’ can add together ints, doubles, etc., so, GHCi gives the most possible generic polymorphic type possible instead of limiting the function to handle only ‘Int’ or only ‘Double’ for instance. No, we get a typeclass-constrained polymorphic type variable.

Each type class offers a standard set of functions that can be used across several concrete types.

So, if a variable is typeclass-constrained with ‘Num a’, we can get a list of concrete types that have an instance of ‘Num’:

λ> :info Num
λ> :info Fractional

We say it’s constrained because we still don’t know the concrete type of a, but we do know it can only be one of the types that has the required type class instance.

We can create a more specific/concrete type from a more polymorphic one, but not the other way arround:

λ> n = 1
λ> i = n :: Int
λ> d = n :: Double

λ> :type n
n :: Num p => p

λ> :type i
i :: Int

λ> :type d
d :: Double

λ> d + n
2.0

λ> d + i
...error...

The error is because ‘i’ is no longer polymorphic. After GHCi evaluates ‘d’ which is a ‘Double’, the ‘(+)’ function requiries that the other parameter is also a ‘Double’. In ‘d + n’ it works because ‘n’ is polymorphic ‘Num’ and can be inferred to be ‘Double’, but ‘i’ is ‘Int’, a concrete type, not a polymorphic type, so, it cannot be converted to ‘Double’ which is required to match the first argument ‘d’ and thus the error. In short, we can't do ‘d + i’ because they are not polymorphic and they concrete types are different so they have different definitions on how to implement addition.

Multiple typeclass constraints

One typeclass constraint for each variable:

(Num a, Num b) => a -> b -> b

Both constraints on the same variable ‘a’:

(Ord a, Num a) => a -> a -> Ordering

Nothing to the left of the typeclass arrow ‘=>’ shows up at the term level. The tuple of constraints _does_ represent a product, or conjunction of constraints.


==== Question about associativity left and right ====
[DATETIME: Mon, 2020-01-27 11:04]

Thanks to #haskell-beginners@merijn (again) ☺

THE ARROW ASSOCIATES TO THE RIGHT, BUT **APPLICATION** IS LEFT-ASSOCIATIVE.

**REMEMBER**: parens in type signatures just imply grouping, not precedence.

So "f x y z" == "(((f x) y) z)"

But "a -> b -> c -> d" == "a -> (b -> (c -> d))"

So applying a function to an 'a' returns a new function (consuming the remaining arguments)

ME: "a -> (b -> (c -> d))" looks like it should apply like "f (x (y z)))".

Consider this: If you apply 'f' to an 'a' then what's left?
A function that still needs a 'b' and a 'c'
But with "f (x (y z))" 'f' only ever gets one argument
Which is "x (y z)"

@TODO
Does the right-associativeness of ‘(->)’ in the type signatures just mean the function will take on param at a time, from _left_ to right, providing the currying thing‽

**REMEMBER**: parens in type signatures just imply grouping, not precedence.

===== Currying =====
[DATETIME: Mon, 2020-01-27 14:16]

It looks like functions take multiple arguments in Haskell, but the truth is that we have a chain of nested functions: all functions in Haskell take one argument and return one result. When a function appear to take multiple functions, in truth, it takes one argument and returns another function that takes the next argument, and so on until all the arguments have been consumed and the final result is produced.

Each arrow ‘->’ in a type signature represents one argument and one result, with the final type being the final result.

data (->) a b

In ‘(+) :: Num a => a -> a -> a’, the ‘a -> a -> a’ represent successive function applications.

The way the type constructor for functions, (->), is defined makes currying the default in Haskell. This is because it is an infix operator and right associative. Because it associates to the right, types are implicitly parenthesized like so:

f :: a -> a -> a

is the same as 

f :: a -> (a -> a)

and

map :: (a -> b) -> [a] -> [b]

is the same as

map :: (a -> b) -> ([a] -> [b])

The association here, or grouping into parentheses, is not to control precedence or order of evaluation; it only serves to group the parameters into argument and result, since there can only be one argument and one result per arrow. Since all the arrows have the same precedence, the associativity does not change the precedence or order of evaluation.

Explicit parenthesization, as when an input parameter is itself a function (such as in map, above), may be used to indicate order of evaluation, but the implicit associativity of the function type does not mean the inner or final set of parentheses, i.e., the result type, evaluates first. Application is evaluation; in other words, the only way to evaluate anything is by applying functions, and function application is left associative. So, the leftmost, or outermost, arguments will be evaluated first.

==== Partial Application ====
[DATETIME: Mon, 2020-01-27 17:04]

add :: Integer -> Integer -> Integer
add n m = n + m

λ> add1 = add 1
λ> :type add1
add1 :: Integer -> Integer
λ> add1 10
11

‘add’ takes _one_ argument and returns a function that takes _one_ argument which then returns the final result.

Partially applying subtraction and division functions is trickier because they are not is not associative and commutative by default ([[http://mathforum.org/library/drmath/view/72185.html|link]]).

sub :: Integer -> Integer -> Integer
sub dividend divisor = dividend - divisor

λ> subFrom5 = sub 5
λ> subFrom5 1
4

When we apply ‘sub’ to 5, 5 is the dividend. But we want to pass the amount to subtract as the first argument, so we can have functions like ‘sub1’ or ‘sub10’. For that we can use **sectioning**:

sub1 :: Integer -> Integer
sub1 = (subtract 1)

λ> sub1 1
0
λ> sub1 (-1)
-2

over2 :: Double -> Double
over2 = (/ 2)

λ> over2 1
0.5

__NOTE__ that we do the sectioning placing the operator function to the left, so for the subtraction, the argument already applied is the divisor, and for the divistion/fraction the argument already applied is the denominator. It is a way of forcing partially-applying the second argument first.

==== Manual currying and uncurrying ====
To uncurry we unest two functions and replace them with a tuple of two values.

Curried and uncurried ‘(+)’:

(+) :: Num a => a -> a -> a
(+) :: Num a => (a, a) -> a

* Uncurried functions: One function, many arguments.
* Curried functions: Many functions, one argument apiece.

==== Currying and uncurrying existing functions ====
λ> curry f a b = f (a, b)
λ> :t curry
curry :: ((a, b) -> t) -> a -> b -> t

In ‘((a, b) -> t)’, the outer parens mean a function that returns ‘t’. The function takes two params ‘a’ and ‘b’. The inner set of params with the tuple ‘(a, b)’ mean the fuction really takes two params. It is not curried. It requires both params at once.

‘f’ takes ‘a’ and ‘b’. The return type is implicit. A function must return something, in this case, some type ‘t’.

curry takes a function that expects two “curried params” and turns it into a function that must be applied to a tuple of those two params, effectively making it require the two params at once, in one go.

λ> uncurry f (a, b) = f a b
λ> :type uncurry
uncurry :: (t1 -> t2 -> t3) -> (t1, t2) -> t3

A function ‘f’ that requires two params at once (because of the tuple ‘(a, b)’ and produces a function that accepts one param at a time.

==== Sectioning ====
The term sectioning specifically refers to the partial application of infix operators, which has a special syntax that allows you to choose whether you’re partially applying the operator to the first or the second argument.

The side of the operator makes no difference when the function is commutative:

λ> addX = (+ 1)
λ> addY = (1 +)
λ> addX 1
2
λ> addY 1
2

But it does make a difference when the function is not commutative:

λ> overTwo = (/ 2)
λ> twoOver = (2 /)
λ> overTwo 1
0.5
λ> twoOver 1
2.0

λ> minusOne = (subtract 1)
λ> oneMinus = (1 -)
λ> minusOne 1
0
λ> oneMinus 1
0

‘(1 -)’ could also be ‘(1 `subtract`)’.

λ> powerTwo = (^ 2)
λ> twoPower = (2 ^)
λ> powerTwo 3
9
λ> twoPower 3
8

λ> hello = ("hello " ++)
λ> world = (++ " world")
λ> hello "world"
"hello world"
λ> world "hello"
"hello world"

λ> contains3 = (3 `elem`)
λ> contains3 [1, 2, 4]
False
λ> contains3 [1, 2, 3, 4]
True

===== Polymorphism =====
Polymorph is a word of relatively recent provenance. It was invented in the early 19th century from the Greek words poly for “many” and morph for “form.” The -ic suffix in polymorphic means “made of.” So, “polymorphic” means “made of many forms.” In programming, this is understood to be in contrast to monomorphic, “made of one form.”

Broadly speaking, type signatures may have three kinds of types:
* concrete (Int, Double, etc.).
* constrained polymorphic (Num a, Ord b, etc.).
* parametrically polymorphic (a, b, etc.).

Two categories of polymorphism:
* parametric polymorphism (variables, fully polymorphic).
* constrained polymorphism (type class, ad-hoc polymorphism). Implemented with type classes.

id :: a -> a

Maximally polymorphic signature for ‘id’. Any type is allowed.

By default, type variables are resolved at the left-most part of the type signature and are fixed once sufficient information to bind them to a concrete type is available. That is, once an ‘a’ is decided upon a concrete type, say, ‘Integer’, all other references to ‘a’ will be ‘Integer’ as well.

We do not know we can add ‘a’ and ‘a’ together, but we know we can add ‘Num a’ and ‘Num a’ together.

Methods/functions are implemented through type classes. Since ‘a’ bears no typeclass information, there is no function we can apply to ‘a’. We can simply just return it.

A type ‘Num a’ implements only the functions in the ‘Num’ typeclass, but an ‘Integer’, for instance, implements functions both from ‘Num’ and ‘Integral’ type classes, due to the additive nature of type class inheritance. The more concrete a type is, the less flexibility on the type, but the more operations can be performed on it, and vice-versa.

If something has an instance of Num but not an instance of Integral, it can’t implement the methods of the Integral type class. A subclass cannot override the methods of its superclass.

A function is polymorphic when its type signature has variables that can represent more than one type. That is, its parameters are polymorphic. Parametric polymorphism refers to fully polymorphic (unconstrained by a type class) parameters. Parametricity is the property we get from having parametric polymorphism. Parametricity means that the behavior of a function with respect to the types of its (parametrically polymorphic) arguments is uniform. The behavior cannot change just because it was applied to an argument of a different type.

==== Polymorphic constants ====
λ> :type (-10)
(-10) :: Num a => a
λ> :typ 6.3
6.3 :: Fractional p => p
λ> :type (-10) + 6.3
(-10) + 6.3 :: Fractional a => a

Doesn't work:

λ> 6 / length [1, 2]

‘/’ works on Fractional, but ‘length’ returns Int. Can't convert from a more specific type to a more generic one. ‘length’ isn't polymorphic enough. ‘Fractional’ doesn't include the type ‘Int’.

λ> 6 / fromIntegral (length [1, 2])
3.0

==== Question about fromIntegral ====

https://hoogle.haskell.org and search for ‘fromIntegral’ ([[https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:fromIntegral|link]]). It is in Prelude.

‘:i Prelude.fromIntegral’ says "defined in GHC.Real", but ‘:i Real’ does not show ‘fromIntegral’.

GHC.Real is a module, but with :i Real you're asking about the typeclass called Real. The fully qualified name of the typeclass would be GHC.Real.Real.

‘:i GHC.Real.Real’ doesn't show it either.

well, of course not! that only shows the methods which actually *belong* to Real

`:browse GHC.Real` should show it
The point is that GHC.Real is *different* from GHC.Real.Real, so while the first one (i.e. the module) contains it, the second (the class) does not

yes, ':browse ModuleNameHere' shows everything exported by that module

===== Type Inference =====
Haskell’s type inference is built on an extended version of the Damas-Hindley-Milner type system.

Haskell will infer the most generally applicable (polymorphic) type that is still correct.

λ> greet s = "Hey " ++ s
λ> :type greet
greet :: [Char] -> [Char]

Because GHCi knows ‘++’ and sees it is being used with a list of ‘Char’, it knows ‘s’ can only be ‘Char’.

But here we are back to a polymorphic type signature:

λ> greet x y = x ++ y
λ> :type greet
greet :: [a] -> [a] -> [a]

GHCi knows ‘++’ concatenates lists, but it has no idea about ‘x’ and ‘y’, so it infers the parametrically polymorphic types.


f :: Num a => a -> a -> a
f x y = x + y + 1

λ> :t f 1
f 1 :: Num a => a -> a

Still ‘Num a’ because there is nothing forcing GHCi to infer that 1 or x or y should have a more specific, concrete type.

λ> :t f (1 :: Int)
f (1 :: Int) :: Int -> Int

Now we gave the compiler a concrete type, so, it must infer the other ‘a’s to be of that same concrete type as well.










===== The End =====
