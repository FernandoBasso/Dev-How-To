Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-02-10T07:18:00-03:00

====== ch09 Lists ======
Created Monday 10 February 2020

===== Lists =====

* Collection, or plurality, of values.
* An infinite series of values, acting as a stream data type.


===== The list datatype =====

'''
λ> :info []
data [] a = [] | a : [a]
'''

‘[]’ is the type constructor for lists as well as the data constructor for the empty list.

‘[]’ is a nullary constructor because it takes no arguments.

‘:’ is the infix //cons// operator.

This constructor is recursive because it mentions its own type ‘[a]’ as one of the members of the product.


===== Pattern matching on lists =====

We can pattern-match on data constructors, and list data constructors are not exception. We match on the first argument to the infix ‘:’ cons operator, and the rest, after it.

'''
λ> myHead (x : xs) = x
λ> :t myHead
myHead :: [a] -> a
'''

Since we don't need ‘xs’, let's use ‘_’:

'''
λ> myHead (x : _) = x
'''

The tail function:

'''
λ> myTail (_ : xs) = xs
λ> :t myTail
myTail :: [a] -> [a]
'''

WE ARE NOT GRACEFULLY HANDLING EMPTY LISTS. THESE ARE NOT SAFE FUNCTIONS.

'''
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

safeTail        :: [a] -> Maybe [a]
safeTail []     = Nothing
safeTail (_:[]) = Nothing
safeTail (_:xs) = Just xs
'''


===== List’s syntactic sugar =====

'''
λ> [1, 2, 3] ++ [4] == (1 : 2 : 3 : []) ++ 4 : []
True
'''

“cons cells” and “spines”.

The cons cells are the list datatype’s second data constructor, ‘a : [a]’, the result of recursively prepending a value to “more list.” The cons cell is a conceptual space that values may inhabit.

The spine is the connective structure that holds the cons cells together and in place. This structure nests the cons cells rather than ordering them in a right-to-left row. Because different functions may treat the spine and the cons cells differently, it is important to understand this underlying structure.

===== Using ranges to construct lists =====

For “ranging” a type it is required that the type have an instance of the ‘Enum’ type class.

'''
λ> [1..5]
[1,2,3,4,5]

λ> ['a', 'c', 'z']
"acz"

λ> ['a', 'c' .. 'z']
"acegikmoqsuwy"

λ> [1, 5 .. 30]
[1,5,9,13,17,21,25,29]

λ> [0, 5 .. 30]
[0,5,10,15,20,25,30]
'''

And the ‘enumFrom...’ family of functions. The first arg must be lower than the second, or we get an empty list.

===== IRC Chat =====

{{./chat1.png}}


[11:06:28] <systemhalted> This is the first time I saw learnhaskell GitHub. I was happy to see it suggesting to not install platform.
[11:26:48] <Fernando-Basso> I wonder why technologies sometimes (most of the times?) get into these messy situations where something that comes “standard” is not the recommended thing.
[11:27:10] <Fernando-Basso> One example is the date stuff in Java. People recommend to use a lib instead.
[11:27:59] <merijn> Fernando-Basso: Because the better thing was implemented later, but too much depend on the current standard thing that you can't just change/replace it, because everything will break
[11:28:12] <merijn> Fernando-Basso: It took ages to fix the Applicative/Monad nonsense in base for that reason
[11:28:35] <Fernando-Basso> I see. Many things don't get fixed in JS because of the same reason.
[11:28:43] <Fernando-Basso> Things get added, but not fixed.
[11:29:19] <merijn> Fernando-Basso: In Haskell the most egregious things tend to get fixed, but it can't take along while because it often means entire ecosystems have to update, so you have to be *really* sure your fix is actually better
[11:32:53] <Fernando-Basso> That is OK then. There is a limit to what even the best minds can conceive and create.
[11:35:10] <merijn> Fernando-Basso: Fun facts: It took several years before monadic IO as we have it now was invented, Applicative wasn't discovered until like 15 years after the first Haskell implementation ;)
[11:35:24] <Fernando-Basso> :o
[11:35:58] <merijn> Fernando-Basso: The first paper on Applicatives was written in 2004
[11:36:39] <merijn> Fernando-Basso: Before IO Haskell programs were implemented via "main :: [IOResponse] -> [IORequest]" taking an infinite (lazy) list of IO responses as input and producing a lazy infinite list of IO Requests
[12:46:36] <Fernando-Basso> merijn, Interesting. Although I have not reached such topics (still on chapter 09 on lists), I'll note this down so I can ponder about this further when I learn about such topics. Thanks.

[12:48:21] <merijn> Fernando-Basso: Well, that's mostly obsolete history now :p
[12:49:17] <merijn> Fernando-Basso: I just find that many beginners think that a lot of this stuff was arrived at through divine intervention, or something, while in reality these things were invented way after the language and then adopted because they were just that awesome
[12:50:37] <solonarv> we do still have some such warts in the language
[12:50:53] <solonarv> String, Num, and the plethora of partial functions in base spring to mind
[12:51:39] <boxscape> at least all of those are library issues rather than issues inherent to the language

[12:51:50] <merijn> solonarv: You call Num a wart, but it's unclear what would be better
[12:53:22] <Fernando-Basso> merijn, Well, I like to know the history about stuff, languages, decisions, etc. I like to know why things are the way they are, when it was because of lack of design (like PHP), or too short time to implement (like JS in the beginning), or when people just believed it was a good decision that turned out to be a bad one, or turned out bad after paradigm change or technology evolution.

[12:54:38] <OK_b00m3r> that's going to be a long list :)
[12:55:07] <Fernando-Basso> And it tends to infinity, for sure, because such problems will never cease, I believe.
[12:55:27] <solonarv> merijn: I'm not sure what should happen with abs/signum, but at least a diamond-shaped lattice of Additive-AdditiveGroup/Semiring-Ring would be a better split of + - * fromInteger

[12:56:13] <OK_b00m3r> Fernando-Basso: exactly. i was trying to find the words to say that.
[12:56:20] <OK_b00m3r> Fernando-Basso: much like organic matter versus time
[12:56:28] <Fernando-Basso> Well put!
[12:56:33] <OK_b00m3r> ;-)

[13:00:59] <Fernando-Basso> Anyway, the reason I like to know such things whenever I can is because I am not of the type “lang X sucks, lang Y is the best”. I like to have informed opinion about stuff as much as possible. Of course I do like some things/langs more than others, though, just that I do not join the rage/troll party.
[13:01:23] <OK_b00m3r> Fernando-Basso: *nod*

===== Extracting portions of lists =====

See ‘take’, ‘drop’ and ‘splitAt’, ‘takeWhile’, ‘dropWhile’.

'''
λ> takeWhile (< 3) [1..5]
[1,2]
λ> takeWhile (> 3) [1..5]
[]
'''


===== List comprehensions =====

'''
λ> [ x ^ 2 | x <- [1..10]]
[1,4,9,16,25,36,49,64,81,100

λ> [ x ^ 2 | x <- [1..10], (x >) 5]
[36,49,64,81,100]

λ> [ x ^ 2 | x <- [1..10], even x]
[4,16,36,64,100]
'''

With two generators, apply each value from the first generator to all of the values of the second generator. That is, add 1 to 1 and 10, then add 2 to 1 and 10, then add 3 to 1 and 10, then add 4 to 1 and 10.

'''
λ> [x + y | x <- [1 .. 4], y <- [1, 10]]
[2,11,3,12,4,13,5,14]
'''

And using a predicate to tell that the result should not be greater than 10.

'''
λ> [x + y | x <- [1 .. 4], y <- [1, 10], x + y <= 10]
[2,3,4,5]
'''

Creating tuples:

'''
λ> [(x, y) | x <- ['A' .. 'C'], y <- [1, 2]]
[('A',1),('A',2),('B',1),('B',2),('C',1),('C',2)]

[(x, y) | x <- mySqr,
          y <- mySqr,
          x < 50,
          y > 50]
'''

With strings (which are lists of ‘Char’:

'''
λ> elem 'R' "Tomb Raider"
True
'''


{{./list-comprehension-troad-exe.png}}


===== Spines and non-strict-evaluation =====

Lists are a recursive series of cons cells ‘a : [a]’ terminated by the empty list ‘[]’.

A cons cell ‘:’ contains a value and another cons cell.

'''
          :
         / \
         1  :
           / \
           2  :
             / \
             3 []
'''

So, ‘1 : (2 : (3 : []))’ is the syntax we use, but does not mean 1 exists before the cons cell ‘:’. That is just syntax sugar.

Because of this and the way non-strict evaluation works, you can evaluate cons cells independently of what they contain. It is possible to evaluate only the spine of the list without evaluating individual values. It is also possible to evaluate only part of the spine of a list and not the rest of it.

Haskell’s evaluation is non-strict, so the list isn’t constructed until it’s
consumed. A list is evaluated down, forming a blueprint representation of what the list will be like when it is forced to be constructed.

Inspecting evaluation:

'''
λ> aToZ = ['a' .. 'z']
λ> :sprint aToZ
aToZ = _
λ> take 1 aToZ
"a"
λ> :sprint aToZ
aToZ = 'a' : _
λ> take 5 aToZ
"abcde"
λ> :sprint aToZ
aToZ = 'a' : 'b' : 'c' : 'd' : 'e' : _
'''

‘length’ is only strict in the spine, meaning it only forces evaluation of the spine, not the values. Unfortunately, ‘:sprint aToZ’ behaves as though we had forced e valuation of the entire list. This is a quirk of how GHCi evaluates code.

==== Spines are evaluated independently of values ====

Values in Haskell get reduced to weak head normal form by default. By “normal form,” we mean that the expression is fully evaluated. “Weak head normal form” means the expression is only evaluated as far as is necessary to reach a data constructor.

Weak head normal form (WHNF) is a larger set and contains both the possibility that the expression is fully evaluated (normal form) and the possibility that the expression has been evaluated to the point of arriving at a data constructor or lambda awaiting an argument. For an expression in weak head normal form, further evaluation may be possible once another argument is provided. If no further inputs are possible, then it is still in WHNF but also in normal form (NF).

‘(++) "hel" "lo"’ is fully applied but not yet evaluated. It is not WHNF because the function has been fully applied. It is not in NF becasuse it has not yet been evaluated.

'''
λ> s = "hel" ++ "lo"
λ> :sprint s
s = _
'''

[10:50:04] <Fernando-Basso> Is 1 in normal form?
[10:54:28] <Fernando-Basso> I don't see why this is not normal form: ‘(++) "tomb" " raider"’.
[10:57:49] <boxscape> Fernando-Basso whether or not 1 is in normal form depends on what exactly you mean by 1; (++) "tomb" "raider" is not in weak-head normal form (what we usually use instead of normal form) because the outer-most term is an application of a function rather than a constructor or a lambda.

[10:59:24] <boxscape> if you really mean normal form and not weak-head normal form then the reason is simply that it's not fully evaluated
[10:59:36] <boxscape> the fully evaluated version being "tomb raider"

A function not fully applied is WHNF. A constructor or lambda is WHNF.

[11:01:53] <boxscape> Fernando-Basso that's in principle correct, though in the context of haskell specifically, when you type "1" in a haskell file, the compiler will actually interpret that as "fromInteger 1"
[11:03:26] <Fernando-Basso> Gosh!
[11:04:05] <dminuoso> Also, another useful bit to understand, is that in GHC a polymorphic value is secretly parametrized over a type.
[11:04:40] <dminuoso> Which adds more mud

[11:01:53] <boxscape> Fernando-Basso that's in principle correct, though in the context of haskell specifically, when you type "1" in a haskell file, the compiler will actually interpret that as "fromInteger 1"
[11:05:31] <Fernando-Basso> :O

[11:07:04] <Fernando-Basso> Perhaps the only way to truly learn Haskell is to be part of the Report process and a GHC core dev :D
[11:07:25] <dminuoso> Fernando-Basso: No, you just explore ideas that are orthogonal to becoming a productive programmer.
[11:07:35] <dminuoso> Knowing what normal form is, is in no way required for being a competent developer

[11:08:12] <Fernando-Basso> Roger that.
[11:09:01] <Fernando-Basso> I'm 41 now. Learning math in general and Haskell will is being fun, but hard.
[11:09:33] <Fernando-Basso> I thank you all for the kind and insightful help!

[11:10:39] <jonap> Come on! this's fun: http://dirk.rave.org/combinatris/
[11:10:46] <Fernando-Basso> s/will//
[11:10:48] <dminuoso> You dont need any math or theoretical computer science in order to become a productive haskell developer
[11:10:56] <dminuoso> Fernando-Basso: https://patrickmn.com/software/the-haskell-pyramid/
[11:11:01] <dminuoso> This might be an enlightening read

[11:16:30] <Fernando-Basso> dminuoso, Yeah, makes sense. I am generally one more than one side when it comes to opinions. I agree with the post, makes sense, but I also feel like Haskell learning curve is like Vi learning curve in that old, known joke: https://i.imgur.com/xjWucy4.png
[11:16:52] <Fernando-Basso> s/one/on/

Using this syntax, bottom (‘undefined’) is not part of the spine, so, no problems to evaluate the length.

'''
λ> list = [1, undefined, 3]
λ> length list
3
'''

We know that ‘length’ only evaluates the spine because even though we have bottom/undefined in the list, using ‘length’ on the list doesn't crash. Try ‘print list’ and see.

'''
λ> xs = 1 : (undefined : (3 : []))
λ> len xs
3
'''

NOTE: The REPL automatically prints stuff, so, if you do not assign the “result” to a variable or use something that doesn't allow lazyness, you'll get an error (in the REPL).

Looks like this causes ‘undefined’ to be part of the spine itself, though:

'''
λ> xs = [1] ++ undefined ++ [3]
λ> length xs
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:48:13 in interactive:Ghci6
'''

This is OK:

'''
λ> xs = [1] ++ [undefined] ++ [2]
λ> length xs
3
'''

An expression cannot be in normal form or weak head normal form if the outermost part of the expression isn’t a data constructor. It can’t be in normal form if any part of the expression is unevaluated.

Remember that the REPL implicitly uses ‘print’ and automatically prints stuff:

'''
λ> [1, 2, 3]
[1,2,3]
λ> 1 : (2 : (3 : []))
[1,2,3]
λ> xs = [1, undefined, 3]
λ> ys = 1 : (undefined : (3 : []))
'''

No error defining ‘xs’ and ‘ys’ because the values are not evaluated (lazyness, remember?). But if you do not assign the last two lists to variables, then the REPL tries to print them, and when it gets to the ‘undefined’, DOOM.

'''
λ> [1, undefined, 3]
[1,*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:43:5 in interactive:Ghci10
λ>
λ> 1 : (undefined : (3 : []))
[1,*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:44:6 in [[interactive:Ghci10]]
'''


'''
λ> take 1 $ map (+ 1) [1, undefined]
[2]
λ> take 2 $ map (+ 1) [1, undefined]
[2,*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:48:24 in [[interactive:Ghci11]]
'''

Non-strict, lazy evaluation allows for this not to throw an error:

'''
λ> r = (+ 1) undefined
'''

But when it is forced to evaluate:

'''
λ> r
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err
  undefined, called at <interactive>:51:11 in [[interactive:Ghci11]]
'''

A common mantra for performance sensitive code in Haskell is, “lazy in the spine, strict in the leaves.”



===== The End =====




