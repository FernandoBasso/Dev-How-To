Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2020-02-04T07:34:17-03:00

====== ch07 More Functional Patterns ======
Created Tuesday 04 February 2020

===== Make it func-y =====

A function is an instruction for producing an output from an input, or argument. Functions are applied to arguments that bind their parameters to values. The fully applied function with its arguments is then evaluated to produce the output, or result. Haskell functions are first-class entities that:

* Can be values in expressions, lists, or tuples.
* Can be passed as arguments to a function.
* Can be returned from a function as a result.
* Make use of syntactic patterns.

===== Arguments and parameters =====
All Haskell values can be arguments to functions (they are first-class values), and Haskell functions are values (first-class values) too.

--------------------

===== Question Function Val Polymorphic =====
@TODO @QUESTION

'''
x :: Int
x = 1
vx f = x

vy f = 1
'''

Why does the above produces these types:

'''
λ> :t vx
vx :: p -> Int

λ> :t vy
vy :: Num p1 => p2 -> p1
'''

Note this too:

'''
vy f = 1 :: Int
'''

Produces

'''
λ> :t vy
vy :: p -> Int
'''

So, if the number is constrained polymorphic, we get the type signature ‘Num p1 => p2 -> p1’, but if it is a concrete type like ‘Int’, then we get the signature ‘p -> Int’... Why?

This code...

'''
num :: Int
num = 1

fnF f = num

fnG f = 1

fnH f = 1 :: Int
'''

...produces these types

'''
λ> :t fnF
fnF :: p -> Int

λ> :t fnG
fnG :: Num p1 => p2 -> p1

λ> :t fnH
fnH :: p -> Int
'''

--------------------

Q: How to tell a value from a function value?
A: A value is not applied to arguments, and a function value is.

Applying a func- tion binds its parameters to values. Type parameters become bound to a type, and function variables are bound to a value. The binding of variables concerns not only the application of function arguments, but also things like let expressions and where clauses.


NOTE: Careful with let, where scoping when creating binds, can careful with shadowing variables. Haskell is lexically-scoped, that is, scope is resolved by the location of stuff in the source code. The lexically innermost binding for a variable of a particular name always takes precedence.

===== Anonymous Functions =====

'''
λ> (\x -> x * 3) 5
15

λ> triple = (\x -> x * 3)
λ> :t triple
triple :: Num a => a -> a
'''


--------------------

===== Question about myFlip =====
@TODO @QUESTION

Undertand this...

'''
mflip f = \x -> \y -> f y x

myFlip :: (a -> b -> c) -> b -> a -> c
myFlip f x y = f y x
'''

‘myFlip’ takes a function ‘(a -> b -> c)’. It produces ‘c’, so, we change only the order of the two params, so, the result is something like ‘(b -> a -> c)’.

--------------------

===== Pattern Matching =====

Patterns can include things as diverse as undefined variables, numeric literals, and list syntax. Pattern matching matches on any and all data constructors.

TIP: Pattern matching is something akin to method overload in some languages. Depending on the signature (number of params, types), we dispatch a different version of the method.

Patterns are matched against values, or data constructors, not types.

Pattern-match from the most espcific to the more generic.

Incomplete pattern matches applied to data they don’t handle will return bottom, a non-value used to denote that the program cannot return a value or result. ‘:set -Wall’ is your friend.

===== Case Expressions =====

case expr of
  thing -> return value
  otherThing -> other return value

===== Higher-order functions =====

'''
λ> (-) 2 1
1

λ> flip (-) 2 1
-1
'''

--------------------
@TODO

'''
flip' :: (a -> b -> c) -> b -> a -> c
flip' f = \ x y -> f y x
'''

What is this ‘\ x y’ syntax?

--------------------

REMEMBER: Parenthesis in type signature does not change the order of evaluation. It is just for grouping.

One reason we want HOFs is to manipulate how functions are applied to arguments.

===== Guards =====
No equal sign after function name and params, but use equal signs on each guard expression:

'''
myAbs :: Integer -> Integer
myAbs x
  | x < 0     = (negate x)
  | otherwise = x
'''


===== Function composition =====

IMPORTANT: Looks like composed functions work only with one argument. In Ramda, we can pass multiple arguments to the first function in the chain of composed functions. Looks like it is not the case in Haskell. True, all Haskell functions take one argument, but there is suggar to allow us to “pretend” we can pass multiple argument. It seems that suggar does not happen in function composition.


'''
λ> :info .
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .
'''

In English:
1. Given a function b to c,
2. and a function a to b,
3. return a function a to c.

'''
(f . g) x = f (g x)
'''

Example:

'''
λ> xs = [1..5]
λ> negate . sum $ xs
-15
'''

Ordinary function application has a precedence of 10 (out of 10). The composition operator has a precedence of 9. By using the ‘$’, we signal that the application to the arguments should happen after the functions are already composed.

'''
λ> take 5 . reverse $ [1..10]
[10,9,8,7,6]

λ> take 5 (enumFrom 3)
[3,4,5,6,7]

λ> take 5 $ enumFrom 3
[3,4,5,6,7]

λ> take 5 . enumFrom $ 3
[3,4,5,6,7]

λ> f lim ini = take lim . enumFrom $ ini
λ> f 3 9
[9,10,11]

λ> take 5 . filter odd . enumFrom $ 19
[19,21,23,25,27]
'''


===== Point-free style =====
The “point” in “point-free” refers to the arguments, not (as it may seem) to the function composition operator.

Quite often, point-free code is tidier on the page and easier to read, as it helps the reader focus on the functions rather than the data that is being shuffled around.

'''
f . g = \x -> f (g x)
f . g . h = \x -> f (g (h x))
'''

Examples:

'''
λ> f = negate . sum
λ> f [1..5]
-15

λ> g = foldr (+)
λ> g 0 [1..5]
15

λ> h = length . filter (== 'a')
λ> h "abracadabra"
5
'''

https://wiki.haskell.org/Pointfree

Not point-free:

'''
blah x = x
addAndDrop x y = x + 1
reverseMkTuple a b = (b, a)
reverseTuple (a, b) = (b, a)
'''

Point-free versions of the above:

'''
blah = id
addAndDrop = const . (1 +)
reverseMkTuple = flip (,)
reverseTuple = uncurry (flip (,))
'''


===== Demonstrating composition =====

'''
λ> :t putStr
putStr :: String -> IO ()

λ> :t putStrLn
putStrLn :: String -> IO ()

λ> :t print
print :: Show a => a -> IO ()
'''

Another exmaple:

'''
myPrint :: Show a => a -> IO ()
myPrint thing = putStrLn (show thing)

-- With point-free style and function composition.
display :: Show a => a -> IO ()
display = putStrLn . show
'''


'''
f :: Char -> String
f c = [c]

g :: String -> [String]
g s = [s]

h :: Char -> [String]
h = g . f

-- λ> h 'k'
-- ["k"]
'''

“nullary” data constructor. It’s neither a sum or a product — it’s just a single value.



===== The End =====
















