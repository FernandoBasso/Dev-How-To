Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-12-18T09:43:52-03:00

====== HackerRank Shell ======
Created Wednesday 18 December 2019


===== Intro =====
Unless otherwise noted, assume all scripts contain the following shebang:

'''
#!/usr/bin/env bash
'''


===== Easy Challenges =====
https://www.hackerrank.com/domains/shell



==== Let's Echo ====
Tags: @cmdline @shell @bash @echo @printf
Links: [[https://www.hackerrank.com/challenges/bash-tutorials-lets-echo|challenge]]

'''
$ echo HELLO

$ printf '%s\n' HELLO
'''


==== Looping With Numbers ====
Tags: @cmdline @shell @bash @numbers @looping @for
Links: [[https://www.hackerrank.com/challenges/bash-tutorials---looping-with-numbers|challenge]]

'''
for (( i = 1; i <= 9; ++i ))
do
  echo "$i"
done
'''


Or using ranges:
'''
$ printf '%d\n' {1..50}
'''


==== Looping And Skipping ====
Tags: cmdline, numbers @looping @for
Links: [[https://www.hackerrank.com/challenges/bash-tutorials---looping-and-skipping|challenge]]

'''
for (( i = 1; i <= 9; ++i ))
do
  if (( i % 2 == 0 ))
  then
    continue
  fi
  echo "$i"
done

$ bash script.sh
1
3
5
7
9
'''


Could also use ''echo:''
'''
$ echo -ne {1..9..2} '\n'
'''

The ''-e'' option is to enable some escapes. ''help echo'' for more.

Or using ''seq'':
'''
$ seq -s ' ' 1 2 9
'''


==== A Personalized Echo ====
Tags: @cmdline @read @echo
Links: [[https://www.hackerrank.com/challenges/bash-tutorials---a-personalized-echo|challenge]]

'''
$ read -r name
$ printf 'Welcome %s\n' "$name"
'''


==== The World of Numbers ====
Tags: @cmdline @shell @bash @numbers @math @bc @ranges
Links: [[https://www.hackerrank.com/challenges/bash-tutorials---the-world-of-numbers|challenge]]

First, see this clever use of range to produce the math expressions:

'''
$ read -r x y
8 2

$ printf '%s\n' "$x"{+,-,*,/}"$y"
8+2
8-2
8*2
8/2
'''

Then, feed those expressions to ''bc'':

'''
$ read -r x y
8 2

$ printf '%s\n' "scale=2; $x"{+,-,*,/}"$y" | bc
10
6
16
4.00
'''

If ''y'' is //negative//, like ''-2'' we would receive an error:

'''
$ read -r x y
5 -2

$ printf '%s\n' "scale=2; $x"{+,-,*,/}"$y" | bc
3
(standard_in) 2: syntax error
-10
-2.50
'''

Adding parenthesis prevents the error, because our expression would be like ''5--2'', but ''5-(-2)'' is OK with ''bc'':

'''
$ read -r x y
5 -2

$ printf '%s\n' "scale=2; $x"{+,-,*,/}"($y)" | bc
3
7
-10
-2.50
'''

Or something more manual and verbose:

'''
read x </dev/stdin
read y </dev/stdin

printf '%d\n' $(( x + y ))
printf '%d\n' $(( x - y ))
printf '%d\n' $(( x * y ))
printf '%d\n' $(( x / y ))
'''

NOTE: The challenge wants integer division, so, we simply omit ''bc'''s scale special variable.

==== Getting started with conditionals ====
Tags: @cmdline @shell @bash @conditionals
Links: [[https://www.hackerrank.com/challenges/bash-tutorials---getting-started-with-conditionals|challenge]]

'''
read -r answer

case "$answer" in
  [Yy]*)
    printf '%s\n' YES
    ;;
  [Nn]*)
    printf '%s\n' NO
    ;;
  *)
    printf '%s\n' 'What the poopâ€½ ðŸ’©'
    ;;
esac
'''

'''
$ bash script.sh 
yes
YES

$ bash script.sh 
Y
YES

$ bash script.sh
n
NO

$ bash script.sh
lol
What the poopâ€½ ðŸ’©
'''


==== More on Conditionals ====
Tags: @cmdline @shell @bash @conditionals @math
Links: [[https://www.hackerrank.com/challenges/bash-tutorials---more-on-conditionals|challenge]]

Solution based on side lengths.

* equilateral: ''x == y && y == z''
* scalene: ''x != y && y != z && z != x''
* isosceles: any other

The script:
'''
read -r x
read -r y
read -r z

[[ "$x" == "$y" ]] && [[ "$y" == "$z" ]] && echo EQUILATERAL && exit 0
[[ "$x" != "$y" ]] && [[ "$y" != "$z" ]] && [[ "$z" != "$x" ]] && echo SCALENE && exit 0
echo ISOSCELES && exit 0

'''
==== Arithmetic Operations ====
* Tags: @cmdline @shell @bash @math @bc
* Links: [[https://www.hackerrank.com/challenges/bash-tutorials---arithmetic-operations|challenge]]

'''
expression="$1"
printf '%.3f\n' "$(echo "$expression" | bc -l)"
'''

''bc -l'' produces up to 6 decimal places. If we use bc scale to 3, for instance, depending on the result, we would produce wront results because printf %f format specifier does rounding by itself.

''bc'' scale is 0 by default if not explicitly set. Also, ''bc'' does no rounding.

''printf'' rounds up from 6, and down from 5:

'''
$ printf '%.3f\n' 1.2583
1.258
$ printf '%.3f\n' 1.2585
1.258
$ printf '%.3f\n' 1.2586
1.259
'''

Only when the number after 8 passes 5, that is, 6 and above, is that the number is rounded up to 1.259. If one uses ''scale=3'' in ''bc'', then it truncates (does not round) to three decimal places and ''printf'' has no way to round up, making the solution to the exercise incorrect. Therefore, we use ''bc -l'' without scale, or use ''scale=4'' at least.







===== The End =====

